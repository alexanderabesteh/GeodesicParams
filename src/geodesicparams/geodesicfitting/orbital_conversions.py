#!/usr/bin/env python3
"""
Procedures for computing orbital elements in a two-body system.

These procedures include the mean anomaly, orbital period, mean motion, etc. A procedure for 
converting from the Newtonian parametrization of a geodesic to its integrals of motion 
counterpart has also been implemented.

"""

from mpmath import acos, tan, atan, sqrt, sin, pi, cos

from ..ellipsefitting.guaranteed_AML_ellipse_fit.ellipse_estimates import parametric_rep, conv_coeffs_to_init_pos

def ellipse_middle(ecc, semi_maj):
    """
    Computes the x,y coordinates of the center of the ellipse generated by a Kepler orbit
    with eccentricity <ecc> and semi-major axis <semi_maj>.

    Parameters
    ----------
    ecc : float
        The eccentricity of the ellipse from 0 < ecc < 1.
    semi_maj : float
        The semi major axis of the ellipse, where semi_maj > 0.

    Returns
    -------
    x_mid : float
        The x coordinate of the center of the ellipse.
    y_mid : float
        The y coordinate of the center of the ellipse.

    """

    periapsis_dist = semi_maj * (1 - ecc**2) / (1 + ecc * cos(0))
    x_mid = -semi_maj + periapsis_dist
    y_mid = 0

    return x_mid, y_mid

def parametric_t(ecc, semi_maj, x_mid, y_mid, rot_angle): 
    """
    Computes a lambda function that returns the t value of the parametric functions
    X(t) and Y(t) given a pair of x,y coordinates.

    Note that the t value returned by the lambda function needs to be corrected by 
    integer multiples of pi.

    Parameters
    ----------
    ecc : float
        The eccentricity of the ellipse from 0 < ecc < 1.
    semi_maj : float
        The semi major axis of the ellipse, where semi_maj > 0.
    x_mid : float
        The x coordinate of the center of the ellipse.
    y_mid : float
        The y coordinate of the center of the ellipse.
    rot_angle : float
        The rotation angle of the ellipse in radians. 

    Returns
    -------
    callable
        A lambda function that returns the t coordinate in the parametric functions 
        X(t) and Y(t) from a given pair of x,y coordinates.

    """

    a = semi_maj
    b = a * sqrt(1 - ecc**2)
    a1 = semi_maj * cos(rot_angle)
    b1 = b * sin(rot_angle)
    c1 = a * sin(rot_angle)
    d1 = b * cos(rot_angle)

    x_comp = lambda x, y : (y - y_mid + (d1 * (x - x_mid) / b1)) / (c1 + (d1 * a1 / b1))
    y_comp = lambda x, y : 1/b1 * (a1 * x_comp(x, y) - (x - x_mid))
    
    return lambda x, y : atan(y_comp(x, y) / x_comp(x, y))

def correct_t(t, x, y, x_mid):
    """
    Computes the correction factor for a given t value returned by parametric_t.

    The correction factor is an integer multiple of pi (either pi or 2pi).

    Parameters
    ----------
    t : float
        The t value to be corrected.
    x : float
        The x coordinate used to generate the t value.
    y : float
        The y coordinate used to generate the t value.
    x_mid : float
        The x coordinate of the center of the ellipse.

    Returns
    -------
    float
        The corrected t value.

    """

    if x > x_mid and y < 0:
        return t + 2 * pi
    elif x < x_mid:
        return t + pi

    return t

def convert_parametric_to_newton(coeffs, x1, y1, x2, y2, ecc, semi_maj):
    """
    Given 2 pairs of x,y coordinates on an ellipse rotated about the origin, return
    the projections of the data points onto a Kepler orbit with eccentricity <ecc> and
    semi-major axis <semi_maj>.

    Parameters
    ----------
    coeffs : list
        The list of coefficients defining an ellipse.
    x1 : float
        The x coordinate of the first data point.
    y1 : float
        The y coordinate of the first data point.
    x2 : float
        The x coordinate of the second data point.
    y2 : float
        The y coordinate of the second data point.
    ecc : float
        The eccentricity of the ellipse from 0 < ecc < 1.
    semi_maj : float
        The semi major axis of the ellipse, where semi_maj > 0.

    Returns
    -------
    x_t1 : float
        The first x coordinate projected onto the Kepler orbit.
    y_t1 : float
        The first y coordinate projected onto the Kepler orbit.
    x_t2 : float
        The second x coordinate projected onto the Kepler orbit.
    y_t2 = : float
        The second y coordinate projected onto the Kepler orbit.

    """

    rot_ang = conv_coeffs_to_init_pos(coeffs)[2]
    x_mid, y_mid = ellipse_middle(ecc, semi_maj)

    x_parametric, y_parametric = parametric_rep(coeffs)
    t_para = parametric_t(ecc, semi_maj, x_mid, y_mid, rot_ang)

    # The t values of the data points
    t_para1 = correct_t(t_para(x1, y1), x1, y1, x_mid)
    t_para2 = correct_t(t_para(x2, y2), x2, y2, x_mid)

    # The x,y coordinates projected onto the Kepler orbit
    x_t1 = x_parametric(t_para1)
    y_t1 = y_parametric(t_para1)
    x_t2 = x_parametric(t_para2)
    y_t2 = y_parametric(t_para2)

    return x_t1, y_t1, x_t2, y_t2

def mean_anomaly(x1, y1, x2, y2, ecc, semi_maj):
    """
    Given 2 pairs of x,y coordinates in a Kepler orbit, return the mean anomaly at 
    both points.

    Parameters
    ----------
    x1 : float
        The x coordinate of the first data point.
    y1 : float
        The y coordinate of the first data point.
    x2 : float
        The x coordinate of the second data point.
    y2 : float
        The y coordinate of the second data point.
    ecc : float
        The eccentricity of the ellipse from 0 < ecc < 1.
    semi_maj : float
        The semi major axis of the ellipse, where semi_maj > 0.

    Returns
    -------
    mean1 : float
        The mean anomaly of the first data point.
    mean2 : float
        The mean anomaly of the second data point.

    """

    dist1 = sqrt(x1**2 + y1**2)
    dist2 = sqrt(x2**2 + y2**2)
    true_anomaly = lambda x : acos(((semi_maj * (1 - ecc**2) / x) - 1) / ecc)

    """
    Compute the true anomalies of the points given the distances dist1 and dist2 from 
    the origin at (0, 0) to the points on the ellipse. Since there are two true anomalies 
    for a corresponding distance from the origin to a point on an ellipse (except at 
    horizontal vertices), the function that computes the true anomaly changes depending on
    the y coordinate of the point.
    """
    if y1 < 0:
        nu1 = true_anomaly(-dist1 + 2 * semi_maj) + pi
    else:
        nu1 = true_anomaly(dist1)
    
    if y2 < 0:
        nu2 = true_anomaly(-dist2 + 2 * semi_maj) + pi
    else:
        nu2 = true_anomaly(dist2)

    # Compute eccentric anomalies
    denom = sqrt((1 + ecc) / (1 - ecc))
    ecc_anomaly = lambda nu : 2 * atan(tan(nu / 2) / denom)
    ecc_anom1 = ecc_anomaly(nu1)
    ecc_anom2 = ecc_anomaly(nu2)

    mean_anomaly = lambda x : x - ecc * sin(x)
    mean1 = mean_anomaly(ecc_anom1)
    mean2 = mean_anomaly(ecc_anom2)

    return mean1, mean2

def orbital_elements(ecc, semi_maj, x1, y1, x2, y2, t1, t2):
    """
    Computes the orbital elements of a two body system, including the mean motion n, the
    standard gravitational parameter mu, and the orbital period P.

    This is done by using the change in mean anomaly / the change in time to compute the
    mean motion, which can then be used to compute the standard gravitational parameter and
    the orbital period.

    Parameters
    ----------
    ecc : float
        The eccentricity of the ellipse from 0 < ecc < 1.
    semi_maj : float
        The semi major axis of the ellipse, where semi_maj > 0.
    x1 : float
        The x coordinate of the first data point.
    y1 : float
        The y coordinate of the first data point.
    x2 : float
        The x coordinate of the second data point.
    y2 : float
        The y coordinate of the second data point.
    t1 : float
        The time at which the point (x1, y1) was observed (the initial time).
    t2 : float
        The time at which the point (x2, y2) was observed (the final time).

    Returns
    -------
    n : float
        The mean motion of the orbiting body.
    standard_grav : float
        The standard gravitational parameter.
    orbital_period : float
        The orbital period of the orbiting body.

    """

    mean1, mean2 = mean_anomaly(x1, y1, x2, y2, ecc, semi_maj) 
    n = (mean2 - mean1) / (t2 - t1)
    standard_grav = semi_maj**3 * n**2
    orbital_period = 2 * pi * sqrt(semi_maj**3 / standard_grav)

    return n, standard_grav, orbital_period

def convert_newtonian(ecc, semi_maj, orbit_inc, sign_ang, b_rot, e_charge, grav_const, speed_light, perm):
    """
    Convert the Newtonian parametrization of geodesics involving the eccentricity <ecc>, the
    semi major axis <semi_maj>, and orbital inclination <orbit_inc> to its integrals of motion
    counterpart (specific energy, specific angular momentum, and carter constant).

    This procedure only works for space-times with a vanishing cosmological constant (
    Schwarzschild, Reissner-Nordstrom, Kerr, and Kerr-Newman).

    Parameters
    ----------
    ecc : float
        The eccentricity of the ellipse from 0 < ecc < 1.
    semi_maj : float
        The semi major axis of the ellipse, where semi_maj > 0.
    orbit_inc : float
        The orbital inclination of the geodesic in radians.
    sign_ang : int
        An integer, either +1 if the orbit is prograde or -1 if the orbit is retrograde.
    b_rot : float
        The angular momentum of the central body, where rot >= 0.
    e_charge : float
        The electric charge of the central body, where e_charge >= 0.
    grav_const : float
        The gravitational constant.
    speed_light : float
        The speed of light.
    perm : float
        The permitivity of free space.

    Returns
    -------
    energy : float
        The specific energy squared of the geodesic.
    ang_mom : float
        The specific angular momentum of the geodesic.
    carter : float
        The specific carter constant of the geodesic.

    """

    # Initial parameters
    schwarz_rad = 2 * grav_const / speed_light**2
    char_length = e_charge**2 * grav_const / (4 * pi * perm * speed_light**4)
    theta_min = (pi/2 - orbit_inc) / sign_ang
    nu_min2 = cos(theta_min)**2
    p = semi_maj * (1 - ecc**2)
    r_min = p / (1 + ecc)
    r_max = p / (1 - ecc)
    horizon = lambda r : r**2 - schwarz_rad * r + char_length
    
    # Functions used in the conversion procedure
    f_r = lambda r : r**4 + b_rot**2 * (r * (r + 2) + nu_min2 * horizon(r))
    g_r = lambda r : 2 * b_rot * r
    h_r = lambda r : r * (r - 2) + (nu_min2 / (1 - nu_min2)) * horizon(r)
    d_r = lambda r : (r**2 + b_rot**2 * nu_min2) * horizon(r)

    f1 = f_r(r_min); g1 = g_r(r_min); h1 = h_r(r_min); d1 = d_r(r_min)
    f2 = f_r(r_max); g2 = g_r(r_max); h2 = h_r(r_max); d2 = d_r(r_max)

    # Determinants of the matrices in []
    kappa =  d1 * h2 - h1 * d2
    epsilon = d1 * g2 - g1 * d2
    rho = f1 * h2 - h1 * f2
    eta = f1 * g2 - g1 * f2
    sigma = g1 * h2 - h1 * g2

    # Specific energy squared of the geodesic
    energy = (kappa * rho + 2*epsilon*sigma + sign_ang * 2 * sqrt(sigma * (
        sigma*epsilon**2 + rho * epsilon * kappa - eta * kappa**2))) / (rho**2 + 4 * eta * sigma)

    # Specific angular momentum of the geodesic
    ang_mom = -g1*sqrt(energy)/h1 + sign_ang * sqrt((g1**2 * energy / h1**2) + 
        (f1*energy - d1) / h1)

    # Specific carter constant of the geodesic
    beta = b_rot**2 * (1 - energy)
    carter = nu_min2 * (beta + (ang_mom**2 / (1 - nu_min2)))

    return energy, ang_mom, carter
