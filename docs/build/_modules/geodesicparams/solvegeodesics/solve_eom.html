

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>geodesicparams.solvegeodesics.solve_eom &mdash; GeodesicParams 0.2.1 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css?v=80d5e7a1" />
      <link rel="stylesheet" type="text/css" href="../../../_static/css/theme.css?v=66b59bf7" />

  
      <script src="../../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../../_static/documentation_options.js?v=37f418d5"></script>
      <script src="../../../_static/doctools.js?v=9a2dae69"></script>
      <script src="../../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../../index.html" class="icon icon-home">
            GeodesicParams
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <!-- Local TOC -->
              <div class="local-toc"></div>
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">GeodesicParams</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../../index.html">Module code</a></li>
      <li class="breadcrumb-item active">geodesicparams.solvegeodesics.solve_eom</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for geodesicparams.solvegeodesics.solve_eom</h1><div class="highlight"><pre>
<span></span><span class="ch">#!/usr/bin/env python</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Procedures for inverting and solving the equations of motion for a variety of spacetimes.</span>

<span class="sd">Equations of motion used by these procedures are required to be in standard form, which can</span>
<span class="sd">be achieved through convert_polynomial and solve_geodesic_orbit. Period matrices are required</span>
<span class="sd">for each procedure (except for when the equation of motion is a degree 2 polynomial), and are</span>
<span class="sd">either computed through the period_matrices modules in riemannsurfaces, or provided directly.</span>

<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">from</span> <span class="nn">mpmath</span> <span class="kn">import</span> <span class="n">im</span><span class="p">,</span> <span class="n">re</span><span class="p">,</span> <span class="n">fabs</span><span class="p">,</span> <span class="n">sign</span><span class="p">,</span> <span class="n">matrix</span><span class="p">,</span> <span class="n">exp</span><span class="p">,</span> <span class="n">ln</span><span class="p">,</span> <span class="n">quad</span><span class="p">,</span> <span class="n">nint</span><span class="p">,</span> <span class="n">log</span><span class="p">,</span> <span class="n">mpc</span><span class="p">,</span> <span class="n">chop</span><span class="p">,</span> <span class="n">sqrt</span>
<span class="kn">from</span> <span class="nn">numpy</span> <span class="kn">import</span> <span class="n">load</span> <span class="k">as</span> <span class="n">npload</span><span class="p">,</span> <span class="n">save</span><span class="p">,</span> <span class="n">array</span>
<span class="kn">from</span> <span class="nn">pickle</span> <span class="kn">import</span> <span class="n">dump</span><span class="p">,</span> <span class="n">load</span>
<span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">sympify</span><span class="p">,</span> <span class="n">Poly</span><span class="p">,</span> <span class="n">degree</span><span class="p">,</span> <span class="n">sin</span> <span class="k">as</span> <span class="n">spsin</span><span class="p">,</span> <span class="n">asin</span> <span class="k">as</span> <span class="n">spasin</span><span class="p">,</span> <span class="n">sqrt</span> <span class="k">as</span> <span class="n">spsqrt</span><span class="p">,</span> <span class="n">Symbol</span><span class="p">,</span> <span class="n">lambdify</span><span class="p">,</span> <span class="n">apart</span><span class="p">,</span> <span class="n">together</span><span class="p">,</span> <span class="n">solve</span><span class="p">,</span> <span class="n">oo</span><span class="p">,</span> <span class="n">collect</span><span class="p">,</span> <span class="n">pprint</span><span class="p">,</span> <span class="n">sympify</span><span class="p">,</span> <span class="n">assemble_partfrac_list</span><span class="p">,</span> <span class="n">apart_list</span>

<span class="kn">from</span> <span class="nn">..utilities</span> <span class="kn">import</span> <span class="n">separate_zeros</span><span class="p">,</span> <span class="n">inlist</span>
<span class="kn">from</span> <span class="nn">..riemannsurfaces.riemann_funcs.elliptic_funcs</span> <span class="kn">import</span> <span class="n">weierstrass_P</span><span class="p">,</span> <span class="n">inverse_weierstrass_P</span><span class="p">,</span> <span class="n">weierstrass_zeta</span><span class="p">,</span> <span class="n">weierstrass_sigma</span>
<span class="kn">from</span> <span class="nn">..riemannsurfaces.riemann_funcs.hyperelp_funcs</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">..riemannsurfaces.period_matrices.periods_genus1_first</span> <span class="kn">import</span> <span class="n">periods_firstkind</span>
<span class="kn">from</span> <span class="nn">..riemannsurfaces.period_matrices.periods_genus1_second</span> <span class="kn">import</span> <span class="n">periods_secondkind</span>
<span class="kn">from</span> <span class="nn">..riemannsurfaces.period_matrices.periods_genus2_first</span> <span class="kn">import</span> <span class="n">periods</span><span class="p">,</span> <span class="n">eval_period</span><span class="p">,</span> <span class="n">int_genus2_first</span><span class="p">,</span> <span class="n">set_period_globals_genus2</span>
<span class="kn">from</span> <span class="nn">..riemannsurfaces.integrations.integrate_hyperelliptic</span> <span class="kn">import</span> <span class="n">myint_genus2</span><span class="p">,</span> <span class="n">int_genus2_complex</span><span class="p">,</span> <span class="n">myint_genus2_second</span><span class="p">,</span> <span class="n">int_genus2_complex_second</span>
<span class="kn">from</span> <span class="nn">..riemannsurfaces.period_matrices.periods_genus2_second</span> <span class="kn">import</span> <span class="n">periods_second</span>

<span class="c1"># Global period matrices</span>
<span class="n">periods_inverse</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">riemannM</span> <span class="o">=</span> <span class="mi">0</span>

<div class="viewcode-block" id="invert_eom">
<a class="viewcode-back" href="../../../geodesicparams.solvegeodesics.html#geodesicparams.solvegeodesics.solve_eom.invert_eom">[docs]</a>
<span class="k">def</span> <span class="nf">invert_eom</span><span class="p">(</span><span class="n">polynomial</span><span class="p">,</span> <span class="n">zeros</span><span class="p">,</span> <span class="n">integrand</span><span class="p">,</span> <span class="n">initial_values</span><span class="p">,</span> <span class="n">int_sign</span><span class="p">,</span> <span class="n">substitution</span><span class="p">,</span> <span class="n">digits</span><span class="p">,</span> <span class="n">periodM</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">datafile</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Procedure for inverting equations of motion of trigonometric, elliptic, and </span>
<span class="sd">    hyperelliptic type for various spacetimes. Specifically </span>

<span class="sd">    The polynomial utilized is expected to be in standard form, converted by convert_polynomial.</span>
<span class="sd">    Unless provided, the period matrices have to be computed.</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    polynomial : symbolic</span>
<span class="sd">        A symbolic statement representing the polynomial in standard form.</span>
<span class="sd">    zeros : list</span>
<span class="sd">        A list of complex or real numbers representing the converted zeros of &lt;polynomial&gt;.</span>
<span class="sd">    integrand : symbolic</span>
<span class="sd">        The integrand in the equation above.</span>
<span class="sd">    initial_values : list</span>
<span class="sd">        The initial values converted by the same substitution used to convert &lt;polynomial&gt;.</span>
<span class="sd">    int_sign : int</span>
<span class="sd">        The sign of square root in the differential equation, either +1 or -1. The </span>
<span class="sd">        signs must have also been converted by the same substitution used to convert </span>
<span class="sd">        &lt;polynomial&gt;.</span>
<span class="sd">    substitution : callable</span>
<span class="sd">        The substitution used to convert &lt;polynomial&gt; as a callable lambda function.</span>
<span class="sd">    periodM : list, optional</span>
<span class="sd">        Either a 1x2 list for elliptic equations of motion, representing the period</span>
<span class="sd">        matrices of a genus 1 Riemann surface, or a 2x4 mpmath matrix, representing the</span>
<span class="sd">        period matrix of a genus 2 Riemann surface.</span>
<span class="sd">    digits : int</span>
<span class="sd">        The number of digits to be used in the computation.</span>
<span class="sd">    datafile : string, optional</span>
<span class="sd">        A file name to store information pertaining to the computation, such as the </span>
<span class="sd">        period matrix. This is optional, unlike solve_eom.</span>
<span class="sd">        </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    callable</span>
<span class="sd">        The solution function for the differential equation.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">p</span> <span class="o">=</span> <span class="n">polynomial</span>
    <span class="n">sym</span> <span class="o">=</span> <span class="n">Poly</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="o">.</span><span class="n">gen</span>
    <span class="n">deg_p</span> <span class="o">=</span> <span class="n">degree</span><span class="p">(</span><span class="n">polynomial</span><span class="p">,</span> <span class="n">sym</span><span class="p">)</span>

    <span class="c1"># Hyperelliptic (genus 2)</span>
    <span class="k">if</span> <span class="n">deg_p</span> <span class="o">==</span> <span class="mi">5</span><span class="p">:</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">sympify</span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="n">integrand</span><span class="p">)</span><span class="o">.</span><span class="n">is_polynomial</span><span class="p">()):</span>
            <span class="k">if</span> <span class="n">degree</span><span class="p">(</span><span class="n">Poly</span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="n">integrand</span><span class="p">,</span> <span class="n">sym</span><span class="p">),</span> <span class="n">sym</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span> <span class="ow">and</span> <span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="n">integrand</span><span class="p">)</span><span class="o">.</span><span class="n">coeff</span><span class="p">(</span><span class="n">sym</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="n">integrand</span><span class="p">)</span><span class="o">.</span><span class="n">coeff</span><span class="p">(</span><span class="n">sym</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">datafile</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">invert_hyperelliptic_first</span><span class="p">(</span><span class="n">zeros</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">initial_values</span><span class="p">,</span> <span class="n">int_sign</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="n">integrand</span><span class="p">)</span><span class="o">.</span><span class="n">coeff</span><span class="p">(</span><span class="n">sym</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span><span class="o">.</span><span class="n">evalf</span><span class="p">(),</span> <span class="n">substitution</span><span class="p">,</span> <span class="n">digits</span><span class="p">,</span> <span class="n">periodM</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">invert_hyperelliptic_first</span><span class="p">(</span><span class="n">zeros</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">initial_values</span><span class="p">,</span> <span class="n">int_sign</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="n">integrand</span><span class="p">)</span><span class="o">.</span><span class="n">coeff</span><span class="p">(</span><span class="n">sym</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span><span class="o">.</span><span class="n">evalf</span><span class="p">(),</span> <span class="n">substitution</span><span class="p">,</span> <span class="n">digits</span><span class="p">,</span> <span class="n">periodM</span><span class="p">,</span> <span class="n">datafile</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">degree</span><span class="p">(</span><span class="n">Poly</span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="n">integrand</span><span class="p">,</span> <span class="n">sym</span><span class="p">),</span> <span class="n">sym</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">datafile</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">invert_hyperelliptic_first</span><span class="p">(</span><span class="n">zeros</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">initial_values</span><span class="p">,</span> <span class="n">int_sign</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="n">integrand</span><span class="p">)</span><span class="o">.</span><span class="n">coeff</span><span class="p">(</span><span class="n">sym</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span><span class="o">.</span><span class="n">evalf</span><span class="p">(),</span> <span class="n">substitution</span><span class="p">,</span> <span class="n">digits</span><span class="p">,</span> <span class="n">periodM</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">invert_hyperelliptic_first</span><span class="p">(</span><span class="n">zeros</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">initial_values</span><span class="p">,</span> <span class="n">int_sign</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="n">integrand</span><span class="p">)</span><span class="o">.</span><span class="n">coeff</span><span class="p">(</span><span class="n">sym</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span><span class="o">.</span><span class="n">evalf</span><span class="p">(),</span> <span class="n">substitution</span><span class="p">,</span> <span class="n">digits</span><span class="p">,</span> <span class="n">periodM</span><span class="p">,</span> <span class="n">datafile</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Equations of motions of hyperelliptic type and second kind are not supported.&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Equations of motions of hyperelliptic type and third kind can not be inverted.&quot;</span><span class="p">)</span>

    <span class="c1"># Elliptic (genus 1)</span>
    <span class="k">elif</span> <span class="n">deg_p</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">sympify</span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="n">integrand</span><span class="p">))</span><span class="o">.</span><span class="n">is_polynomial</span><span class="p">(</span><span class="n">sym</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">degree</span><span class="p">(</span><span class="n">Poly</span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="n">integrand</span><span class="p">,</span> <span class="n">sym</span><span class="p">),</span> <span class="n">sym</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">datafile</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">invert_elliptic_first</span><span class="p">(</span><span class="n">polynomial</span><span class="p">,</span> <span class="n">initial_values</span><span class="p">,</span> <span class="n">int_sign</span><span class="p">,</span> <span class="n">integrand</span><span class="p">,</span> <span class="n">substitution</span><span class="p">,</span> <span class="n">periodM</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">invert_elliptic_first</span><span class="p">(</span><span class="n">polynomial</span><span class="p">,</span> <span class="n">initial_values</span><span class="p">,</span> <span class="n">int_sign</span><span class="p">,</span> <span class="n">integrand</span><span class="p">,</span> <span class="n">substitution</span><span class="p">,</span> <span class="n">periodM</span><span class="p">,</span> <span class="n">datafile</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Equations of motion elliptic type and second kind: tbd.&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Equations of motion of elliptic type and third kind cannot be inverted.&quot;</span><span class="p">)</span>

    <span class="c1"># Trigonometric</span>
    <span class="k">elif</span> <span class="n">deg_p</span> <span class="o">&lt;=</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">datafile</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">invert_trigonometric_first</span><span class="p">(</span><span class="n">polynomial</span><span class="p">,</span> <span class="n">initial_values</span><span class="p">,</span> <span class="n">int_sign</span><span class="p">,</span> <span class="n">integrand</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">invert_trigonometric_first</span><span class="p">(</span><span class="n">polynomial</span><span class="p">,</span> <span class="n">initial_values</span><span class="p">,</span> <span class="n">int_sign</span><span class="p">,</span> <span class="n">integrand</span><span class="p">,</span> <span class="n">datafile</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Polynomial </span><span class="si">{</span><span class="n">polynomial</span><span class="si">}</span><span class="s2"> is not of the standard form needed by invert_eom.&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="integrate_eom">
<a class="viewcode-back" href="../../../geodesicparams.solvegeodesics.html#geodesicparams.solvegeodesics.solve_eom.integrate_eom">[docs]</a>
<span class="k">def</span> <span class="nf">integrate_eom</span><span class="p">(</span><span class="n">polynomial</span><span class="p">,</span> <span class="n">zeros</span><span class="p">,</span> <span class="n">substitution</span><span class="p">,</span> <span class="n">integrand</span><span class="p">,</span> <span class="n">datafile</span><span class="p">,</span> <span class="n">digits</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Procedure for integrating equations of motion of trigonometric, elliptic, and </span>
<span class="sd">    hyperelliptic type for various spacetimes. Specifically </span>

<span class="sd">    The polynomial utilized is expected to be in standard form, converted by convert_polynomial.</span>
<span class="sd">    Unless provided, the period matrices have to be computed.</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    polynomial : symbolic</span>
<span class="sd">        A symbolic statement representing the polynomial in standard form.</span>
<span class="sd">    zeros : list</span>
<span class="sd">        A list of complex or real numbers representing the converted zeros of &lt;polynomial&gt;.</span>
<span class="sd">    integrand : symbolic</span>
<span class="sd">        The integrand in the equation above (different from invert_eom).</span>
<span class="sd">    datafile : string</span>
<span class="sd">        A file name (including the ending, i.e .npy, etc) containing information about the</span>
<span class="sd">        computation, such as the period matrix. This is required for the integration.</span>
<span class="sd">    digits : int</span>
<span class="sd">        The number of decimal digits to be used in the computation.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    callable</span>
<span class="sd">        The solution function for the integral.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    1. Fix partial fraction decomposition bug in genus 2 equations of motion.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">p</span> <span class="o">=</span> <span class="n">polynomial</span>
    <span class="n">int_sym</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">integrand</span><span class="o">.</span><span class="n">free_symbols</span><span class="p">)</span> <span class="c1">#Poly((1 / integrand).simplify()).gen</span>
    <span class="n">deg_p</span> <span class="o">=</span> <span class="n">degree</span><span class="p">(</span><span class="n">polynomial</span><span class="p">)</span>

    <span class="c1"># Degree 2 or less</span>
    <span class="k">if</span> <span class="n">deg_p</span> <span class="o">&lt;=</span> <span class="mi">2</span><span class="p">:</span>
        <span class="n">s</span> <span class="o">=</span> <span class="n">Symbol</span><span class="p">(</span><span class="s2">&quot;s&quot;</span><span class="p">)</span>
        <span class="n">sol_nu</span><span class="p">,</span> <span class="n">inits</span> <span class="o">=</span> <span class="n">load</span><span class="p">(</span><span class="nb">open</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">datafile</span><span class="si">}</span><span class="s2">.pickle&quot;</span><span class="p">,</span> <span class="s2">&quot;rb&quot;</span><span class="p">))</span>
        <span class="n">int_sym</span> <span class="o">=</span> <span class="n">int_sym</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">integrand_subs</span> <span class="o">=</span> <span class="n">lambdify</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">integrand</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">int_sym</span><span class="p">,</span> <span class="n">sol_nu</span><span class="p">)</span><span class="o">.</span><span class="n">simplify</span><span class="p">(),</span> <span class="s2">&quot;mpmath&quot;</span><span class="p">)</span>
        <span class="n">res_func</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">s</span> <span class="p">:</span> <span class="n">quad</span><span class="p">(</span><span class="n">integrand_subs</span><span class="p">,</span> <span class="p">[</span><span class="n">inits</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">s</span><span class="p">])</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># Define symbols in the polynomial and integrand</span>
        <span class="n">u</span> <span class="o">=</span> <span class="n">Symbol</span><span class="p">(</span><span class="s2">&quot;u&quot;</span><span class="p">,</span> <span class="n">positive</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span>
        <span class="n">p_sym</span> <span class="o">=</span> <span class="n">Poly</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="o">.</span><span class="n">gen</span>
        <span class="n">int_sym</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">int_sym</span> <span class="k">if</span> <span class="n">i</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="n">p_sym</span><span class="p">]][</span><span class="mi">0</span><span class="p">]</span>
        
        <span class="c1"># Degree 5</span>
        <span class="k">if</span> <span class="n">deg_p</span> <span class="o">==</span> <span class="mi">5</span><span class="p">:</span>
        <span class="c1">#    integrand = integrand.subs(int_sym, u).simplify()</span>
            <span class="n">integrand</span> <span class="o">=</span> <span class="n">integrand</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">int_sym</span><span class="p">,</span> <span class="n">substitution</span><span class="p">)</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">p_sym</span><span class="p">,</span> <span class="n">u</span><span class="p">)</span><span class="o">.</span><span class="n">simplify</span><span class="p">()</span>
            <span class="n">top_int</span><span class="p">,</span> <span class="n">bot_int</span> <span class="o">=</span> <span class="n">integrand</span><span class="o">.</span><span class="n">as_numer_denom</span><span class="p">()</span>
            <span class="n">integrand</span> <span class="o">=</span> <span class="p">(</span><span class="n">top_int</span><span class="o">.</span><span class="n">expand</span><span class="p">()</span> <span class="o">/</span> <span class="n">bot_int</span><span class="p">)</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">u</span><span class="p">)</span>
            <span class="c1">#print(str(integrand))</span>
            <span class="c1">#integrand = sympify(str(integrand).replace(&quot;Abs&quot;, &quot;&quot;))</span>
            <span class="c1">#integrand = integrand.subs(list(integrand.free_symbols)[0], u)</span>
        <span class="c1"># Degree 3</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">integrand</span> <span class="o">=</span> <span class="n">integrand</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">int_sym</span><span class="p">,</span> <span class="n">u</span><span class="p">)</span><span class="o">.</span><span class="n">simplify</span><span class="p">()</span>

        <span class="c1">#pprint(integrand)</span>
        <span class="c1">#f_parfrac = apart(integrand, full = True).evalf()</span>
        <span class="c1">#pprint(f_parfrac)</span>
        
        <span class="c1"># Bronstein partial fraction decomposition</span>
        <span class="n">f_parfrac</span> <span class="o">=</span> <span class="n">assemble_partfrac_list</span><span class="p">(</span><span class="n">apart_list</span><span class="p">(</span><span class="n">integrand</span><span class="p">))</span><span class="o">.</span><span class="n">doit</span><span class="p">()</span><span class="c1">#.doit()</span>
       <span class="c1"># pprint(f_parfrac)</span>
      <span class="c1">#  pprint(together(f_parfrac).simplify())</span>
        <span class="n">poly_fracs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">rat_fracs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">rat_fracs_final</span> <span class="o">=</span> <span class="p">[]</span>
       
        <span class="c1"># Separate rational and polynomial fractions</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">f_parfrac</span><span class="o">.</span><span class="n">args</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">sympify</span><span class="p">(</span><span class="n">f_parfrac</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="n">i</span><span class="p">])</span><span class="o">.</span><span class="n">is_polynomial</span><span class="p">(</span><span class="n">u</span><span class="p">):</span>
                <span class="n">poly_fracs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">f_parfrac</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">rat_fracs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">f_parfrac</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        
        <span class="c1"># Degree 5</span>
        <span class="k">if</span> <span class="n">deg_p</span> <span class="o">==</span> <span class="mi">5</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">rat_fracs</span><span class="p">:</span>
                <span class="n">rat_fracs_final</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">p_sym</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">poly_fracs</span><span class="p">)):</span>
                <span class="n">poly_fracs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">poly_fracs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">p_sym</span><span class="p">)</span>
        <span class="c1"># Degree 3</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Apply substitution to partial fractions</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">rat_fracs</span><span class="p">)):</span>
                <span class="n">rat</span> <span class="o">=</span> <span class="n">apart</span><span class="p">(</span><span class="n">rat_fracs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">substitution</span><span class="p">)</span><span class="o">.</span><span class="n">simplify</span><span class="p">(),</span> <span class="n">full</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span><span class="o">.</span><span class="n">evalf</span><span class="p">()</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">rat</span><span class="o">.</span><span class="n">args</span><span class="p">)):</span>
                    <span class="k">if</span> <span class="n">sympify</span><span class="p">(</span><span class="n">rat</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="n">j</span><span class="p">])</span><span class="o">.</span><span class="n">is_polynomial</span><span class="p">(</span><span class="n">p_sym</span><span class="p">):</span>
                        <span class="n">poly_fracs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">rat</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">rat_fracs_final</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">rat</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">simplify</span><span class="p">())</span>

            <span class="c1"># Fix rational fractions</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">rat_fracs_final</span><span class="p">)):</span>
                <span class="n">top_frac</span><span class="p">,</span> <span class="n">inv_frac</span> <span class="o">=</span> <span class="n">rat_fracs_final</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">as_numer_denom</span><span class="p">()</span>
                <span class="n">coeff</span> <span class="o">=</span> <span class="n">inv_frac</span><span class="o">.</span><span class="n">coeff</span><span class="p">(</span><span class="n">p_sym</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
                <span class="n">new_inv_frac</span> <span class="o">=</span> <span class="p">(</span><span class="n">top_frac</span> <span class="o">/</span> <span class="n">coeff</span> <span class="o">/</span> <span class="n">rat_fracs_final</span><span class="p">[</span><span class="n">i</span><span class="p">])</span><span class="o">.</span><span class="n">simplify</span><span class="p">()</span>
                <span class="n">rat_fracs_final</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">top_frac</span> <span class="o">/</span> <span class="n">coeff</span><span class="p">)</span> <span class="o">*</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">new_inv_frac</span>
       <span class="c1"># pprint(rat_fracs_final)</span>
        <span class="c1">#de = 0</span>
        <span class="c1">#for i in rat_fracs_final:</span>
         <span class="c1">#   de += i</span>
        <span class="c1">#tog = together(de.subs(p_sym, u)).simplify()</span>
        <span class="c1">#pprint(tog)</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">  elif deg_p == 5:</span>
<span class="sd">        p_sym = Poly(p).gen</span>
<span class="sd">        int_sym = [i for i in int_sym if i not in [p_sym]][0]</span>
<span class="sd">        u = Symbol(&quot;u&quot;, positive = True)</span>
<span class="sd">        deg_p = degree(p, p_sym)</span>
<span class="sd">        integrand = integrand.subs(int_sym, substitution).simplify()</span>
<span class="sd">        integrand = integrand.subs(p_sym, u).simplify()</span>
<span class="sd">       # pprint(integrand) </span>
<span class="sd">        f_parfrac = apart(integrand, full = True).evalf()</span>
<span class="sd">        #f_parfrac = assemble_partfrac_list(apart_list(integrand, u)).evalf()</span>
<span class="sd">        f_parfrac = f_parfrac.subs(u, p_sym)</span>
<span class="sd">        pprint(f_parfrac)</span>
<span class="sd">       # f_parfrac = apart(integrand, full = True).evalf()</span>
<span class="sd">        poly_fracs = []</span>
<span class="sd">        rat_fracs = []</span>

<span class="sd">        for i in range(len(f_parfrac.args)):</span>
<span class="sd">            #pprint(f_parfrac.args[i])</span>
<span class="sd">            if sympify(f_parfrac.args[i]).is_polynomial(p_sym):</span>
<span class="sd">                #pprint(f_parfrac.args[i].simplify())</span>
<span class="sd">                poly_fracs.append(f_parfrac.args[i])</span>
<span class="sd">            else:</span>
<span class="sd">                rat_fracs.append(f_parfrac.args[i])</span>


<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Solution procedures</span>
    <span class="k">if</span> <span class="n">deg_p</span> <span class="o">==</span> <span class="mi">5</span><span class="p">:</span>

        <span class="k">def</span> <span class="nf">res_hyp</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
            <span class="n">poly_first</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">poly_first_int</span> <span class="o">=</span> <span class="p">[]</span>

            <span class="n">poly_second</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">poly_second_int</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">res</span> <span class="o">=</span> <span class="p">[]</span>

            <span class="n">s</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
            <span class="c1"># Separate polynomial fracs into 1st degree and 0 degree lists</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">poly_fracs</span><span class="p">)):</span>
                <span class="k">if</span> <span class="n">degree</span><span class="p">(</span><span class="n">poly_fracs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">as_poly</span><span class="p">(</span><span class="n">p_sym</span><span class="p">),</span> <span class="n">p_sym</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Equations of motion of hyperelliptic type and second kind are not supported&quot;</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">degree</span><span class="p">(</span><span class="n">poly_fracs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">as_poly</span><span class="p">(</span><span class="n">p_sym</span><span class="p">),</span> <span class="n">p_sym</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">poly_first</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">poly_fracs</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                    <span class="n">poly_first_int</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">integrate_hyperelliptic_first</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">datafile</span><span class="p">))</span>

                <span class="k">elif</span> <span class="n">degree</span><span class="p">(</span><span class="n">poly_fracs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">as_poly</span><span class="p">(</span><span class="n">p_sym</span><span class="p">),</span> <span class="n">p_sym</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">poly_second</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">poly_fracs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">coeff</span><span class="p">(</span><span class="n">p_sym</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
                    <span class="n">poly_second_int</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">integrate_hyperelliptic_first</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">datafile</span><span class="p">))</span>

            <span class="c1"># Compute integrations of rat fracs</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">rat_fracs_final</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">periodMatrix</span><span class="p">,</span> <span class="n">invert_data</span><span class="p">,</span> <span class="n">eps</span> <span class="o">=</span> <span class="n">npload</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">datafile</span><span class="si">}</span><span class="s2">.npy&quot;</span><span class="p">,</span> <span class="n">allow_pickle</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span>

                <span class="n">eta</span><span class="p">,</span> <span class="n">r1</span><span class="p">,</span> <span class="n">r2</span> <span class="o">=</span> <span class="n">compute_secondkind_periods</span><span class="p">(</span><span class="n">zeros</span><span class="p">,</span> <span class="n">eps</span><span class="p">,</span> <span class="n">periodMatrix</span><span class="p">,</span> <span class="n">datafile</span><span class="p">,</span> <span class="n">digits</span><span class="p">)</span>
                
                <span class="n">integrations</span> <span class="o">=</span> <span class="p">[</span><span class="n">integrate_hyperelliptic_third</span><span class="p">(</span><span class="n">zeros</span><span class="p">,</span> <span class="n">r1</span><span class="p">,</span> <span class="n">r2</span><span class="p">,</span> <span class="n">eta</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">datafile</span><span class="p">,</span> <span class="n">digits</span><span class="p">)(</span><span class="n">s</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">rat_fracs_final</span><span class="p">]</span>
               <span class="c1"># pprint(rat_fracs_final)</span>
                <span class="c1">#pprint(rat_fracs_final[3].as_numer_denom()[0])</span>

                <span class="c1"># Compute rat frac solutions</span>
                <span class="n">rat_res</span> <span class="o">=</span> <span class="p">[</span><span class="n">rat_fracs_final</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">as_numer_denom</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">integrations</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">integrations</span><span class="p">[</span><span class="mi">0</span><span class="p">]))]</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">integrations</span><span class="p">)):</span>
                    <span class="n">rat_res</span> <span class="o">=</span> <span class="p">[</span><span class="n">rat_res</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">rat_fracs_final</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">as_numer_denom</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">integrations</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">integrations</span><span class="p">[</span><span class="n">j</span><span class="p">]))]</span>
               <span class="c1"># pprint(integrations)</span>
               <span class="c1"># print()</span>
                <span class="n">length</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">rat_res</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">length</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
            <span class="c1">#print(&quot;&quot;)</span>
          <span class="c1">#  pprint(rat_res)</span>

            <span class="c1"># Combine polynomial and rat frac solutions</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">length</span><span class="p">):</span>
                <span class="n">poly_res</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">poly_first</span><span class="p">)):</span>
                    <span class="n">poly_res</span> <span class="o">+=</span> <span class="n">poly_first</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">*</span> <span class="n">poly_first_int</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">i</span><span class="p">]</span>

                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">poly_second</span><span class="p">)):</span>
                    <span class="n">poly_res</span> <span class="o">+=</span> <span class="n">poly_second</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">*</span> <span class="n">poly_second_int</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">i</span><span class="p">]</span>

                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">rat_fracs_final</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">res</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">mpc</span><span class="p">(</span><span class="n">poly_res</span><span class="p">))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">res</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">mpc</span><span class="p">((</span><span class="n">poly_res</span> <span class="o">+</span> <span class="n">rat_res</span><span class="p">[</span><span class="n">i</span><span class="p">])</span><span class="o">.</span><span class="n">evalf</span><span class="p">()))</span>
            <span class="c1">#print(res)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">res</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">res</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">res</span>

        <span class="k">return</span> <span class="k">lambda</span> <span class="n">s</span> <span class="p">:</span> <span class="n">res_hyp</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>

    <span class="k">elif</span> <span class="n">deg_p</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
        <span class="n">periods</span><span class="p">,</span> <span class="n">g2</span><span class="p">,</span> <span class="n">g3</span><span class="p">,</span> <span class="n">int_init</span><span class="p">,</span> <span class="n">inits</span> <span class="o">=</span> <span class="n">npload</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">datafile</span><span class="si">}</span><span class="s2">.npy&quot;</span><span class="p">,</span> <span class="n">allow_pickle</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span>
        
        <span class="c1"># Solution function</span>
        <span class="k">def</span> <span class="nf">res_elp</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
            <span class="n">poly_first</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">poly_second</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">res</span> <span class="o">=</span> <span class="p">[]</span>

            <span class="n">s</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>

            <span class="c1"># Split poly fracs into degree 0 and degree 1 polynomials</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">poly_fracs</span><span class="p">)):</span>
                <span class="k">if</span> <span class="n">degree</span><span class="p">(</span><span class="n">poly_fracs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">as_poly</span><span class="p">(</span><span class="n">p_sym</span><span class="p">),</span> <span class="n">p_sym</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">poly_first</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">poly_fracs</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                <span class="k">elif</span> <span class="n">degree</span><span class="p">(</span><span class="n">poly_fracs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">as_poly</span><span class="p">(</span><span class="n">p_sym</span><span class="p">),</span> <span class="n">p_sym</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">poly_second</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">poly_fracs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">coeff</span><span class="p">(</span><span class="n">p_sym</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>

            <span class="n">integrations</span> <span class="o">=</span> <span class="p">[</span><span class="n">integrate_elliptic_third</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">datafile</span><span class="p">)(</span><span class="n">s</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">rat_fracs_final</span><span class="p">]</span>
            <span class="n">rat_res</span> <span class="o">=</span> <span class="n">integrations</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            
            <span class="c1"># Compute rational fracs</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">integrations</span><span class="p">)):</span>
                <span class="n">rat_res</span> <span class="o">=</span> <span class="p">[</span><span class="n">rat_res</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">integrations</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">))]</span>

            <span class="c1"># Combine poly and rat fracs</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)):</span>
                <span class="n">poly_res</span> <span class="o">=</span> <span class="mi">0</span>

                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">poly_first</span><span class="p">)):</span>
                    <span class="n">bounds_res</span> <span class="o">=</span> <span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">inits</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="n">poly_res</span> <span class="o">+=</span> <span class="n">bounds_res</span> <span class="o">*</span> <span class="n">mpc</span><span class="p">(</span><span class="n">poly_first</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>

                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">poly_second</span><span class="p">)):</span>
                    <span class="n">zeta_bounds</span> <span class="o">=</span> <span class="n">weierstrass_zeta</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">inits</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">periods</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">periods</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                    <span class="n">poly_res</span> <span class="o">+=</span> <span class="n">zeta_bounds</span> <span class="o">*</span> <span class="n">mpc</span><span class="p">(</span><span class="n">poly_second</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>

                <span class="n">res</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">mpc</span><span class="p">(</span><span class="n">poly_res</span> <span class="o">+</span> <span class="n">rat_res</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">evalf</span><span class="p">()))</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">res</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">res</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">res</span>

        <span class="k">return</span> <span class="k">lambda</span> <span class="n">s</span> <span class="p">:</span> <span class="n">res_elp</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">deg_p</span> <span class="o">&lt;=</span> <span class="mi">2</span><span class="p">:</span>

        <span class="c1"># Solution function</span>
        <span class="k">def</span> <span class="nf">trig_res</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
            <span class="n">res</span> <span class="o">=</span> <span class="p">[</span><span class="n">res_func</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">s</span><span class="p">]</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">res</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">res</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">res</span>

        <span class="k">return</span> <span class="k">lambda</span> <span class="n">s</span> <span class="p">:</span> <span class="n">trig_res</span><span class="p">(</span><span class="n">s</span><span class="p">)</span></div>


<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Functions with invert_&lt;something&gt; and integrate_&lt;something&gt; have the same inputs as invert_eom</span>
<span class="sd">and integrate_eom respectively. </span>
<span class="sd">&quot;&quot;&quot;</span>

<div class="viewcode-block" id="invert_trigonometric_first">
<a class="viewcode-back" href="../../../geodesicparams.solvegeodesics.html#geodesicparams.solvegeodesics.solve_eom.invert_trigonometric_first">[docs]</a>
<span class="k">def</span> <span class="nf">invert_trigonometric_first</span><span class="p">(</span><span class="n">polynomial</span><span class="p">,</span> <span class="n">initial_values</span><span class="p">,</span> <span class="n">int_sign</span><span class="p">,</span> <span class="n">constant</span><span class="p">,</span> <span class="n">datafile</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Inverts an equation of motion of trigonometric type (&lt;= 2nd degree polynomial).</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    polynomial : symbolic</span>
<span class="sd">        A symbolic statement representing the polynomial in standard form.</span>
<span class="sd">    initial_values : list</span>
<span class="sd">        The initial values converted by the same substitution used to convert &lt;polynomial&gt;.</span>
<span class="sd">    int_sign : int</span>
<span class="sd">        The sign of square root in the differential equation, either +1 or -1. The </span>
<span class="sd">        signs must have also been converted by the same substitution used to convert </span>
<span class="sd">        &lt;polynomial&gt;.</span>
<span class="sd">    constant : real</span>
<span class="sd">       The constant in front of the differential equation.</span>
<span class="sd">    datafile : string, optional</span>
<span class="sd">        A file name to store information pertaining to the computation, such as the </span>
<span class="sd">        initial values. This is optional, unlike solve_eom.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    callable</span>
<span class="sd">        The solution function for the differential equation.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">p</span> <span class="o">=</span> <span class="n">polynomial</span>
    <span class="n">sym</span> <span class="o">=</span> <span class="n">Poly</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="o">.</span><span class="n">gen</span>
    <span class="n">s</span> <span class="o">=</span> <span class="n">Symbol</span><span class="p">(</span><span class="s2">&quot;s&quot;</span><span class="p">)</span>
  
    <span class="n">coeff_2</span> <span class="o">=</span> <span class="n">polynomial</span><span class="o">.</span><span class="n">coeff</span><span class="p">(</span><span class="n">sym</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
    <span class="n">coeff_0</span> <span class="o">=</span> <span class="n">polynomial</span><span class="o">.</span><span class="n">coeff</span><span class="p">(</span><span class="n">sym</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

    <span class="c1"># Invert differential equation</span>
    <span class="n">root</span> <span class="o">=</span> <span class="n">spsqrt</span><span class="p">(</span><span class="o">-</span><span class="n">coeff_2</span><span class="o">/</span><span class="n">coeff_0</span><span class="p">)</span>
    <span class="n">init_const</span> <span class="o">=</span> <span class="n">spasin</span><span class="p">(</span><span class="n">initial_values</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">root</span><span class="p">)</span>
    <span class="n">inverse</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">root</span> <span class="o">*</span> <span class="n">spsin</span><span class="p">(</span><span class="n">int_sign</span> <span class="o">*</span> <span class="n">spsqrt</span><span class="p">(</span><span class="o">-</span><span class="n">coeff_2</span><span class="p">)</span> <span class="o">*</span> <span class="n">constant</span> <span class="o">*</span> <span class="p">(</span><span class="n">s</span> <span class="o">-</span> <span class="n">initial_values</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">init_const</span><span class="p">))</span>

    <span class="n">sol_func</span> <span class="o">=</span> <span class="n">lambdify</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">inverse</span><span class="p">,</span> <span class="s2">&quot;mpmath&quot;</span><span class="p">)</span>

    <span class="c1"># Save inverse polynomial and initial values to &lt;datafile&gt;</span>
    <span class="k">if</span> <span class="n">datafile</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">datafile</span><span class="si">}</span><span class="s2">.pickle&quot;</span><span class="p">,</span> <span class="s2">&quot;wb&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">output_file</span><span class="p">:</span>
            <span class="n">dump</span><span class="p">([</span><span class="n">inverse</span><span class="p">,</span> <span class="n">initial_values</span><span class="p">],</span> <span class="n">output_file</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;In invert_trigonometric_first: solution function saved to, </span><span class="si">{</span><span class="n">datafile</span><span class="si">}</span><span class="s2">.pickle&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">sol_func</span></div>


<div class="viewcode-block" id="invert_elliptic_first">
<a class="viewcode-back" href="../../../geodesicparams.solvegeodesics.html#geodesicparams.solvegeodesics.solve_eom.invert_elliptic_first">[docs]</a>
<span class="k">def</span> <span class="nf">invert_elliptic_first</span><span class="p">(</span><span class="n">polynomial</span><span class="p">,</span> <span class="n">initial_values</span><span class="p">,</span> <span class="n">int_sign</span><span class="p">,</span> <span class="n">constant</span><span class="p">,</span> <span class="n">substitution</span><span class="p">,</span> <span class="n">periodM</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">datafile</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Inverts an equation of motion of elliptic type and first kind.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    polynomial : symbolic</span>
<span class="sd">        A symbolic statement representing the polynomial in standard form.</span>
<span class="sd">    initial_values : list</span>
<span class="sd">        The initial values converted by the same substitution used to convert &lt;polynomial&gt;.</span>
<span class="sd">    int_sign : int</span>
<span class="sd">        The sign of square root in the differential equation, either +1 or -1. The </span>
<span class="sd">        signs must have also been converted by the same substitution used to convert </span>
<span class="sd">        &lt;polynomial&gt;.</span>
<span class="sd">    substitution : callable</span>
<span class="sd">        A lambda function that computes the substitution that casted &lt;polynomial&gt; into</span>
<span class="sd">        standard form.</span>
<span class="sd">    constant : real</span>
<span class="sd">       The constant in front of the differential equation.</span>
<span class="sd">    periodM : matrix, optional</span>
<span class="sd">        A 1x2 list representing the period matricex of a genus 1 Riemann surface.</span>
<span class="sd">    datafile : string, optional</span>
<span class="sd">        A file name to store information pertaining to the computation, such as the </span>
<span class="sd">        initial values. This is optional, unlike solve_eom.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    callable</span>
<span class="sd">        The solution function for the differential equation.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">p</span> <span class="o">=</span> <span class="n">polynomial</span>
    <span class="n">sym</span> <span class="o">=</span> <span class="n">Poly</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="o">.</span><span class="n">gen</span>
    <span class="n">g2</span> <span class="o">=</span> <span class="o">-</span> <span class="n">p</span><span class="o">.</span><span class="n">coeff</span><span class="p">(</span><span class="n">sym</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">g3</span> <span class="o">=</span> <span class="o">-</span> <span class="n">p</span><span class="o">.</span><span class="n">coeff</span><span class="p">(</span><span class="n">sym</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

    <span class="c1"># Compute periods if necessairy</span>
    <span class="k">if</span> <span class="n">periodM</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">periodMatrix</span> <span class="o">=</span> <span class="n">periods_firstkind</span><span class="p">(</span><span class="n">g2</span><span class="p">,</span> <span class="n">g3</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">periodMatrix</span> <span class="o">=</span> <span class="n">periodM</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;periodMatrix = &quot;</span><span class="p">,</span> <span class="n">periodMatrix</span><span class="p">)</span>

    <span class="c1"># Compute initial values</span>
    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">initial_values</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">==</span> <span class="n">oo</span><span class="p">:</span>
        <span class="n">int_initial</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">int_initial</span> <span class="o">=</span> <span class="n">int_sign</span> <span class="o">*</span> <span class="n">inverse_weierstrass_P</span><span class="p">(</span><span class="n">initial_values</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">periodMatrix</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">periodMatrix</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        
        <span class="c1"># Correct initial direction if necessairy</span>
        <span class="k">if</span> <span class="n">sign</span><span class="p">(</span><span class="n">weierstrass_P</span><span class="p">(</span><span class="n">initial_values</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">int_initial</span><span class="p">,</span> <span class="n">periodMatrix</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">periodMatrix</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mi">1</span><span class="p">))</span> <span class="o">!=</span> <span class="n">int_sign</span><span class="p">:</span>
            <span class="n">int_initial</span> <span class="o">*=</span> <span class="o">-</span><span class="mi">1</span>

    <span class="c1"># Save to datafile</span>
    <span class="k">if</span> <span class="n">datafile</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">integrate_initial</span> <span class="o">=</span> <span class="n">int_initial</span>
        <span class="n">initials</span> <span class="o">=</span> <span class="n">initial_values</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">array</span><span class="p">([</span><span class="n">periodMatrix</span><span class="p">,</span> <span class="n">g2</span><span class="p">,</span> <span class="n">g3</span><span class="p">,</span> <span class="n">integrate_initial</span><span class="p">,</span> <span class="n">initials</span><span class="p">],</span> <span class="n">dtype</span> <span class="o">=</span> <span class="nb">object</span><span class="p">)</span>
        <span class="n">save</span><span class="p">(</span><span class="n">datafile</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;In invert_elliptic_first: periodMatrix saved to, </span><span class="si">{</span><span class="n">datafile</span><span class="si">}</span><span class="s2">.npy&quot;</span><span class="p">)</span>

    <span class="k">return</span> <span class="k">lambda</span> <span class="n">s</span> <span class="p">:</span> <span class="n">substitution</span><span class="p">(</span><span class="n">re</span><span class="p">(</span><span class="n">weierstrass_P</span><span class="p">(</span><span class="n">sqrt</span><span class="p">(</span><span class="n">constant</span><span class="p">)</span> <span class="o">*</span> <span class="n">s</span> <span class="o">-</span> <span class="n">initial_values</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">int_initial</span><span class="p">,</span> <span class="n">periodMatrix</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">periodMatrix</span><span class="p">[</span><span class="mi">1</span><span class="p">])))</span></div>


<div class="viewcode-block" id="invert_hyperelliptic_first">
<a class="viewcode-back" href="../../../geodesicparams.solvegeodesics.html#geodesicparams.solvegeodesics.solve_eom.invert_hyperelliptic_first">[docs]</a>
<span class="k">def</span> <span class="nf">invert_hyperelliptic_first</span><span class="p">(</span><span class="n">zeros</span><span class="p">,</span> <span class="n">physical_comp</span><span class="p">,</span> <span class="n">initial_values</span><span class="p">,</span> <span class="n">int_sign</span><span class="p">,</span> <span class="n">constant</span><span class="p">,</span> <span class="n">substitution</span><span class="p">,</span> <span class="n">digits</span><span class="p">,</span> <span class="n">periodM</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">datafile</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Inverts an equation of motion of hyperelliptic type and first kind. The majority</span>
<span class="sd">    of the computation is performed by &lt;orbitdata&gt;.</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    polynomial : symbolic</span>
<span class="sd">        A symbolic statement representing the polynomial in standard form.</span>
<span class="sd">    zeros : list</span>
<span class="sd">        A list of complex or real numbers representing the converted zeros of &lt;polynomial&gt;.</span>
<span class="sd">    physical_comp : int</span>
<span class="sd">        An integer, either 1 or 0, representing the component of the theta divisor which</span>
<span class="sd">        corresponds to physical values (i.e. to the component of the vector of holomorphic</span>
<span class="sd">        differentials dz = [1/sqrt(P(z), z/sqrt(P(z))], where P(z) = &lt;polynomial&gt;).</span>
<span class="sd">    initial_values : list</span>
<span class="sd">        The initial values converted by the same substitution used to convert &lt;polynomial&gt;.</span>
<span class="sd">    int_sign : int</span>
<span class="sd">        The sign of square root in the differential equation, either +1 or -1. The </span>
<span class="sd">        signs must have also been converted by the same substitution used to convert </span>
<span class="sd">        &lt;polynomial&gt;. NOTE: this has yet to be implemented for hyperelliptic differential</span>
<span class="sd">        equations (i.e. this function).</span>
<span class="sd">    substitution : callable</span>
<span class="sd">        The substitution used to convert &lt;polynomial&gt; as a callable lambda function.</span>
<span class="sd">    periodM : list, optional</span>
<span class="sd">        A 2x4 mpmath matrix, representing the period matrix of a genus 2 Riemann surface.</span>
<span class="sd">        If not provided, it will be computed.</span>
<span class="sd">    digits : int</span>
<span class="sd">        The number of digits to be used in the computation.</span>
<span class="sd">    datafile : string, optional</span>
<span class="sd">        A file name to store information pertaining to the computation, such as the </span>
<span class="sd">        period matrix. This is optional, unlike solve_eom.</span>
<span class="sd">        </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    callable</span>
<span class="sd">        The solution function for the differential equation.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">global</span> <span class="n">periods_inverse</span><span class="p">,</span> <span class="n">riemannM</span> 
    <span class="n">realNS</span><span class="p">,</span> <span class="n">complexNS</span> <span class="o">=</span> <span class="n">separate_zeros</span><span class="p">(</span><span class="n">zeros</span><span class="p">)</span>

    <span class="c1"># Compute periods if necessairy</span>
    <span class="k">if</span> <span class="n">periodM</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Computing periods ...&quot;</span><span class="p">)</span>
        <span class="n">periodMatrix</span> <span class="o">=</span> <span class="n">periods</span><span class="p">(</span><span class="n">realNS</span><span class="p">,</span> <span class="n">complexNS</span><span class="p">,</span> <span class="n">digits</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">periodMatrix</span> <span class="o">=</span> <span class="n">periodM</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;periodMatrix = &quot;</span><span class="p">,</span> <span class="n">periodMatrix</span><span class="p">)</span>
    
    <span class="n">omega1</span> <span class="o">=</span> <span class="n">periodMatrix</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">]</span>
    <span class="n">omega2</span> <span class="o">=</span> <span class="n">periodMatrix</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">:</span><span class="mi">4</span><span class="p">]</span>

    <span class="c1"># Define the inverse of the first period matrix and the Riemann matrix tau</span>
    <span class="n">periods_inverse</span><span class="p">,</span> <span class="n">riemannM</span> <span class="o">=</span> <span class="n">set_period_globals_genus2</span><span class="p">(</span><span class="n">periodMatrix</span><span class="p">)</span>

    <span class="c1"># Compute Legendre relation</span>
    <span class="n">m</span> <span class="o">=</span> <span class="n">omega2</span> <span class="o">*</span> <span class="n">omega1</span><span class="o">.</span><span class="n">T</span> <span class="o">-</span> <span class="n">omega1</span> <span class="o">*</span> <span class="n">omega2</span><span class="o">.</span><span class="n">T</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Legendre relation = &quot;</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span>

    <span class="c1"># Check accuracy</span>
    <span class="k">if</span> <span class="n">fabs</span><span class="p">(</span><span class="n">m</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mi">10</span><span class="o">**</span><span class="p">(</span><span class="o">-</span><span class="n">digits</span><span class="p">):</span>
        <span class="n">eps</span> <span class="o">=</span> <span class="n">fabs</span><span class="p">(</span><span class="n">m</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span> <span class="o">*</span> <span class="mi">10</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;WARNING in invert_hyperelliptic_first: accuracy reduced to </span><span class="si">{</span><span class="n">eps</span><span class="si">}</span><span class="s2"> due to Legendre relation.&quot;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">eps</span> <span class="o">=</span> <span class="mi">10</span><span class="o">**</span><span class="p">(</span><span class="o">-</span><span class="n">digits</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>

    <span class="c1"># Compute inital value for Newton method and integration constant</span>
    <span class="k">if</span> <span class="n">physical_comp</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;WARNING in invert_hyperelliptic_first: case that physical component is the first has to be tested&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">initial_values</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">==</span> <span class="n">oo</span><span class="p">:</span>
            <span class="n">initNewton</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">modified_init</span> <span class="o">=</span> <span class="n">spsqrt</span><span class="p">(</span><span class="n">constant</span><span class="p">)</span> <span class="o">*</span> <span class="n">initial_values</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="c1"># Initial value in real zeros</span>
        <span class="k">elif</span> <span class="n">inlist</span><span class="p">(</span><span class="n">initial_values</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">realNS</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">initNewton</span> <span class="o">=</span> <span class="o">-</span><span class="n">eval_period</span><span class="p">(</span><span class="n">inlist</span><span class="p">(</span><span class="n">initial_values</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">realNS</span><span class="p">),</span> <span class="n">oo</span><span class="p">,</span> <span class="n">realNS</span><span class="p">,</span> <span class="n">zeros</span><span class="p">,</span> <span class="n">periodMatrix</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">modified_init</span> <span class="o">=</span> <span class="n">spsqrt</span><span class="p">(</span><span class="n">constant</span><span class="p">)</span> <span class="o">*</span> <span class="n">initial_values</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">eval_period</span><span class="p">(</span><span class="n">inlist</span><span class="p">(</span><span class="n">initial_values</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">realNS</span><span class="p">),</span> <span class="n">oo</span><span class="p">,</span> <span class="n">realNS</span><span class="p">,</span> <span class="n">zeros</span><span class="p">,</span> <span class="n">periodMatrix</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">k</span> <span class="o">=</span> <span class="n">inlist</span><span class="p">(</span><span class="n">initial_values</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">realNS</span> <span class="o">+</span> <span class="p">[</span><span class="n">initial_values</span><span class="p">[</span><span class="mi">1</span><span class="p">]],</span> <span class="n">key</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span> <span class="p">:</span> <span class="n">re</span><span class="p">(</span><span class="n">x</span><span class="p">)))</span>
            
            <span class="c1"># Correct index since the size of &lt;realNS&gt; was changed above when computing &lt;k&gt;</span>
            <span class="k">if</span> <span class="n">k</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">realNS</span><span class="p">):</span>
                <span class="n">k</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">realNS</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>

            <span class="n">h</span> <span class="o">=</span> <span class="n">int_genus2_first</span><span class="p">(</span><span class="n">zeros</span><span class="p">,</span> <span class="n">initial_values</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">realNS</span><span class="p">[</span><span class="n">k</span><span class="p">],</span> <span class="n">digits</span><span class="p">,</span> <span class="n">periodMatrix</span><span class="p">)</span>
            <span class="n">initNewton</span> <span class="o">=</span> <span class="o">-</span><span class="n">eval_period</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">oo</span><span class="p">,</span> <span class="n">realNS</span><span class="p">,</span> <span class="n">zeros</span><span class="p">,</span> <span class="n">periodMatrix</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">-</span> <span class="n">h</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">modified_init</span> <span class="o">=</span> <span class="n">spsqrt</span><span class="p">(</span><span class="n">constant</span><span class="p">)</span> <span class="o">*</span> <span class="n">initial_values</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">eval_period</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">oo</span><span class="p">,</span> <span class="n">realNS</span><span class="p">,</span> <span class="n">zeros</span><span class="p">,</span> <span class="n">periodMatrix</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">h</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">initial_values</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">==</span> <span class="n">oo</span><span class="p">:</span>
            <span class="n">initNewton</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">modified_init</span> <span class="o">=</span> <span class="n">spsqrt</span><span class="p">(</span><span class="n">constant</span><span class="p">)</span> <span class="o">*</span> <span class="n">initial_values</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="c1"># Initial value in real zeros</span>
        <span class="k">elif</span> <span class="n">inlist</span><span class="p">(</span><span class="n">initial_values</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">realNS</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">initNewton</span> <span class="o">=</span> <span class="o">-</span><span class="n">eval_period</span><span class="p">(</span><span class="n">inlist</span><span class="p">(</span><span class="n">initial_values</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">realNS</span><span class="p">),</span> <span class="n">oo</span><span class="p">,</span> <span class="n">realNS</span><span class="p">,</span> <span class="n">zeros</span><span class="p">,</span> <span class="n">periodMatrix</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
            <span class="n">modified_init</span> <span class="o">=</span> <span class="n">spsqrt</span><span class="p">(</span><span class="n">constant</span><span class="p">)</span> <span class="o">*</span> <span class="n">initial_values</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">eval_period</span><span class="p">(</span><span class="n">inlist</span><span class="p">(</span><span class="n">initial_values</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">realNS</span><span class="p">),</span> <span class="n">oo</span><span class="p">,</span> <span class="n">realNS</span><span class="p">,</span> <span class="n">zeros</span><span class="p">,</span> <span class="n">periodMatrix</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">k</span> <span class="o">=</span> <span class="n">inlist</span><span class="p">(</span><span class="n">initial_values</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">realNS</span> <span class="o">+</span> <span class="p">[</span><span class="n">initial_values</span><span class="p">[</span><span class="mi">1</span><span class="p">]],</span> <span class="n">key</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span> <span class="p">:</span> <span class="n">re</span><span class="p">(</span><span class="n">x</span><span class="p">)))</span>
            
            <span class="c1"># Correct index since the size of &lt;realNS&gt; was changed above when computing &lt;k&gt;</span>
            <span class="k">if</span> <span class="n">k</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">realNS</span><span class="p">):</span>
                <span class="n">k</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">realNS</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>

            <span class="n">h</span> <span class="o">=</span> <span class="n">int_genus2_first</span><span class="p">(</span><span class="n">zeros</span><span class="p">,</span> <span class="n">initial_values</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">realNS</span><span class="p">[</span><span class="n">k</span><span class="p">],</span> <span class="n">digits</span><span class="p">,</span> <span class="n">periodMatrix</span><span class="p">)</span>
            <span class="n">initNewton</span> <span class="o">=</span> <span class="o">-</span><span class="n">eval_period</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">oo</span><span class="p">,</span> <span class="n">realNS</span><span class="p">,</span> <span class="n">zeros</span><span class="p">,</span> <span class="n">periodMatrix</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">-</span> <span class="n">h</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">modified_init</span> <span class="o">=</span> <span class="n">spsqrt</span><span class="p">(</span><span class="n">constant</span><span class="p">)</span> <span class="o">*</span> <span class="n">initial_values</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">eval_period</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">oo</span><span class="p">,</span> <span class="n">realNS</span><span class="p">,</span> <span class="n">zeros</span><span class="p">,</span> <span class="n">periodMatrix</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">h</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
   
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Check initial value for Newton method ...&quot;</span><span class="p">)</span>
    <span class="nb">max</span> <span class="o">=</span> <span class="n">check_initNewton</span><span class="p">(</span><span class="n">physical_comp</span><span class="p">,</span> <span class="n">initNewton</span><span class="p">,</span> <span class="p">[</span><span class="n">spsqrt</span><span class="p">(</span><span class="n">constant</span><span class="p">)</span> <span class="o">*</span> <span class="n">initial_values</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">initial_values</span><span class="p">[</span><span class="mi">1</span><span class="p">]],</span> <span class="n">modified_init</span><span class="p">,</span> <span class="n">eps</span><span class="p">)</span>
   
    <span class="c1"># If &lt;datafile&gt; is provided, store initial values, period matrix, and accurary in &lt;datafile&gt;</span>
    <span class="c1"># Otherwise just compute solution</span>
    <span class="k">if</span> <span class="n">datafile</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">initials_mod</span> <span class="o">=</span> <span class="p">[</span><span class="n">spsqrt</span><span class="p">(</span><span class="n">constant</span><span class="p">)</span> <span class="o">*</span> <span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">initial_values</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">physical_comp</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">invert_data</span> <span class="o">=</span> <span class="p">[</span><span class="n">initials_mod</span><span class="p">,</span> <span class="p">[</span><span class="n">modified_init</span> <span class="o">-</span> <span class="n">spsqrt</span><span class="p">(</span><span class="n">constant</span><span class="p">)</span> <span class="o">*</span> <span class="n">initial_values</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="o">-</span><span class="n">initNewton</span><span class="p">],</span> <span class="nb">max</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">invert_data</span> <span class="o">=</span> <span class="p">[</span><span class="n">initials_mod</span><span class="p">,</span> <span class="p">[</span><span class="o">-</span><span class="n">initNewton</span><span class="p">,</span> <span class="n">modified_init</span> <span class="o">-</span> <span class="n">spsqrt</span><span class="p">(</span><span class="n">constant</span><span class="p">)</span> <span class="o">*</span> <span class="n">initial_values</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span> <span class="nb">max</span><span class="p">]</span>
        <span class="n">save</span><span class="p">(</span><span class="n">datafile</span><span class="p">,</span> <span class="n">array</span><span class="p">([</span><span class="n">periodMatrix</span><span class="o">.</span><span class="n">tolist</span><span class="p">(),</span> <span class="n">invert_data</span><span class="p">,</span> <span class="n">eps</span><span class="p">],</span> <span class="n">dtype</span> <span class="o">=</span> <span class="nb">object</span><span class="p">))</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;In invert_hyperelliptic_first: period matrix saved to, </span><span class="si">{</span><span class="n">datafile</span><span class="si">}</span><span class="s2">.npy&quot;</span><span class="p">)</span>
        
        <span class="n">sol</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">affine_list</span> <span class="p">:</span> <span class="n">orbitdata</span><span class="p">(</span><span class="n">initial_values</span><span class="p">,</span> <span class="n">modified_init</span><span class="p">,</span> <span class="p">[</span><span class="n">spsqrt</span><span class="p">(</span><span class="n">constant</span><span class="p">)</span> <span class="o">*</span> <span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">affine_list</span><span class="p">],</span> <span class="n">substitution</span><span class="p">,</span> <span class="n">initNewton</span><span class="p">,</span> <span class="n">eps</span><span class="p">,</span> <span class="nb">max</span><span class="p">,</span> <span class="n">physical_comp</span><span class="p">,</span> <span class="n">datafile</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">sol</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">affine_list</span> <span class="p">:</span> <span class="n">orbitdata</span><span class="p">(</span><span class="n">initial_values</span><span class="p">,</span> <span class="n">modified_init</span><span class="p">,</span> <span class="p">[</span><span class="n">spsqrt</span><span class="p">(</span><span class="n">constant</span><span class="p">)</span> <span class="o">*</span> <span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">affine_list</span><span class="p">],</span> <span class="n">substitution</span><span class="p">,</span> <span class="n">initNewton</span><span class="p">,</span> <span class="n">eps</span><span class="p">,</span> <span class="nb">max</span><span class="p">,</span> <span class="n">physical_comp</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">sol</span></div>


<div class="viewcode-block" id="integrate_hyperelliptic_first">
<a class="viewcode-back" href="../../../geodesicparams.solvegeodesics.html#geodesicparams.solvegeodesics.solve_eom.integrate_hyperelliptic_first">[docs]</a>
<span class="k">def</span> <span class="nf">integrate_hyperelliptic_first</span><span class="p">(</span><span class="n">component</span><span class="p">,</span> <span class="n">datafile</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Procedure for inverting equations of motion of trigonometric, elliptic, and </span>
<span class="sd">    hyperelliptic type for various spacetimes. Specifically </span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    physical_comp : int</span>
<span class="sd">        An integer, either 1 or 0, representing the component of the theta divisor which</span>
<span class="sd">        corresponds to physical values (i.e. to the component of the vector of holomorphic</span>
<span class="sd">        differentials dz = [1/sqrt(P(z), z/sqrt(P(z))], where P(z) = &lt;polynomial&gt;).</span>
<span class="sd">    datafile : string</span>
<span class="sd">        The name of the file containing the data generated by &lt;orbitdata&gt; and</span>
<span class="sd">        &lt;invert_hyperelliptic_first&gt;</span>
<span class="sd">        </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    result : list</span>
<span class="sd">        The result of the integration.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">extended_orbitdata</span> <span class="o">=</span> <span class="n">npload</span><span class="p">(</span><span class="n">datafile</span> <span class="o">+</span> <span class="s2">&quot;_orbitdata.npy&quot;</span><span class="p">,</span> <span class="n">allow_pickle</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span>
    <span class="n">invert_data</span> <span class="o">=</span> <span class="n">npload</span><span class="p">(</span><span class="n">datafile</span> <span class="o">+</span> <span class="s2">&quot;.npy&quot;</span><span class="p">,</span> <span class="n">allow_pickle</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span>
    
    <span class="n">result</span> <span class="o">=</span> <span class="p">[</span><span class="n">extended_orbitdata</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">3</span><span class="p">][</span><span class="n">component</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">invert_data</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">][</span><span class="n">component</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">extended_orbitdata</span><span class="p">))]</span>
    <span class="k">return</span> <span class="n">result</span></div>


<div class="viewcode-block" id="check_initNewton">
<a class="viewcode-back" href="../../../geodesicparams.solvegeodesics.html#geodesicparams.solvegeodesics.solve_eom.check_initNewton">[docs]</a>
<span class="k">def</span> <span class="nf">check_initNewton</span><span class="p">(</span><span class="n">physical_comp</span><span class="p">,</span> <span class="n">initNewton</span><span class="p">,</span> <span class="n">initial_values</span><span class="p">,</span> <span class="n">modified_init</span><span class="p">,</span> <span class="n">eps</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Determine the summation bound for computing the fourier series of the genus 2</span>
<span class="sd">    hyperelliptic theta function.</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    physical_comp : int</span>
<span class="sd">        An integer, either 1 or 0, representing the component of the theta divisor which</span>
<span class="sd">        corresponds to physical values (i.e. to the component of the vector of holomorphic</span>
<span class="sd">        differentials dz = [1/sqrt(P(z), z/sqrt(P(z))], where P(z) = &lt;polynomial&gt;).</span>
<span class="sd">    initNewton : complex</span>
<span class="sd">        The initial value of the Newton method.</span>
<span class="sd">    initial_values : list</span>
<span class="sd">        The initial values [gammain, xin] with gamma and x as in &lt;invert_eom&gt;.</span>
<span class="sd">    modified_init : complex</span>
<span class="sd">        A complex constant = &lt;initial_values[1]&gt; + integration constant (computed in </span>
<span class="sd">        &lt;invert_eom&gt;)</span>
<span class="sd">    eps : float</span>
<span class="sd">        The accuracy of the Newton method.</span>
<span class="sd">    </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    Max : int</span>
<span class="sd">        A natural number in the range 5 &lt;= Max &lt;= 30.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">global</span> <span class="n">periods_inverse</span><span class="p">,</span> <span class="n">riemannM</span>
    <span class="n">g</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="o">/</span><span class="mi">2</span><span class="p">]</span>
    <span class="n">h</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="o">/</span><span class="mi">2</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">physical_comp</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">z</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="mi">2</span> <span class="o">*</span> <span class="n">periods_inverse</span> <span class="o">*</span> <span class="n">matrix</span><span class="p">([</span><span class="n">initial_values</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">modified_init</span><span class="p">,</span> <span class="n">initNewton</span><span class="p">])</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">z</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="mi">2</span> <span class="o">*</span> <span class="n">periods_inverse</span> <span class="o">*</span> <span class="n">matrix</span><span class="p">([</span><span class="n">initNewton</span><span class="p">,</span> <span class="n">initial_values</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">modified_init</span><span class="p">])</span>
                                        
    <span class="nb">max</span> <span class="o">=</span> <span class="mi">5</span>
    <span class="n">f</span> <span class="o">=</span> <span class="n">hyp_theta</span><span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="n">riemannM</span><span class="p">,</span> <span class="nb">max</span><span class="p">)</span>

    <span class="c1"># Determine summation bound</span>
    <span class="k">while</span> <span class="p">((</span><span class="n">fabs</span><span class="p">(</span><span class="n">re</span><span class="p">(</span><span class="n">f</span><span class="p">))</span> <span class="o">&gt;</span> <span class="n">eps</span><span class="o">/</span><span class="mi">10</span> <span class="ow">or</span> <span class="n">fabs</span><span class="p">(</span><span class="n">im</span><span class="p">(</span><span class="n">f</span><span class="p">))</span> <span class="o">&gt;</span> <span class="n">eps</span><span class="o">/</span><span class="mi">10</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">max</span> <span class="o">&lt;</span> <span class="mi">30</span><span class="p">):</span>
        <span class="c1"># Evaluate theta function</span>
        <span class="k">for</span> <span class="n">m1</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="o">-</span><span class="nb">max</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">max</span> <span class="o">+</span> <span class="mi">2</span><span class="p">):</span>
            <span class="n">m</span> <span class="o">=</span> <span class="p">[</span><span class="n">m1</span><span class="p">,</span> <span class="o">-</span><span class="nb">max</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
            <span class="n">char_sum</span> <span class="o">=</span> <span class="mi">0</span>

            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">):</span>
                <span class="n">tau_sum</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">):</span>
                    <span class="n">tau_sum</span> <span class="o">+=</span> <span class="n">riemannM</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">m</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">+</span> <span class="n">g</span><span class="p">[</span><span class="n">j</span><span class="p">])</span> 
                <span class="n">char_sum</span> <span class="o">+=</span> <span class="p">(</span><span class="n">m</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">g</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">*</span> <span class="p">(</span><span class="n">tau_sum</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">z</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">h</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>

            <span class="n">f</span> <span class="o">+=</span> <span class="n">exp</span><span class="p">(</span><span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">pi</span> <span class="o">*</span> <span class="n">char_sum</span><span class="p">)</span>

            <span class="n">m</span> <span class="o">=</span> <span class="p">[</span><span class="n">m1</span><span class="p">,</span> <span class="nb">max</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
            <span class="n">char_sum</span> <span class="o">=</span> <span class="mi">0</span>

            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">):</span>
                <span class="n">tau_sum</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">):</span>
                    <span class="n">tau_sum</span> <span class="o">+=</span> <span class="n">riemannM</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">m</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">+</span> <span class="n">g</span><span class="p">[</span><span class="n">j</span><span class="p">])</span> 
                <span class="n">char_sum</span> <span class="o">+=</span> <span class="p">(</span><span class="n">m</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">g</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">*</span> <span class="p">(</span><span class="n">tau_sum</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">z</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">h</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>

            <span class="n">f</span> <span class="o">+=</span> <span class="n">exp</span><span class="p">(</span><span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">pi</span> <span class="o">*</span> <span class="n">char_sum</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">m2</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="o">-</span><span class="nb">max</span><span class="p">,</span> <span class="nb">max</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">m</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="nb">max</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">m2</span><span class="p">]</span>
            <span class="n">char_sum</span> <span class="o">=</span> <span class="mi">0</span>

            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">):</span>
                <span class="n">tau_sum</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">):</span>
                    <span class="n">tau_sum</span> <span class="o">+=</span> <span class="n">riemannM</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">m</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">+</span> <span class="n">g</span><span class="p">[</span><span class="n">j</span><span class="p">])</span> 
                <span class="n">char_sum</span> <span class="o">+=</span> <span class="p">(</span><span class="n">m</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">g</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">*</span> <span class="p">(</span><span class="n">tau_sum</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">z</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">h</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="n">f</span> <span class="o">+=</span> <span class="n">exp</span><span class="p">(</span><span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">pi</span> <span class="o">*</span> <span class="n">char_sum</span><span class="p">)</span>

            <span class="n">m</span> <span class="o">=</span> <span class="p">[</span><span class="nb">max</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">m2</span><span class="p">]</span>
            <span class="n">char_sum</span> <span class="o">=</span> <span class="mi">0</span>

            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">):</span>
                <span class="n">tau_sum</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">):</span>
                    <span class="n">tau_sum</span> <span class="o">+=</span> <span class="n">riemannM</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">m</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">+</span> <span class="n">g</span><span class="p">[</span><span class="n">j</span><span class="p">])</span> 
                <span class="n">char_sum</span> <span class="o">+=</span> <span class="p">(</span><span class="n">m</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">g</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">*</span> <span class="p">(</span><span class="n">tau_sum</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">z</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">h</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>

            <span class="n">f</span> <span class="o">+=</span> <span class="n">exp</span><span class="p">(</span><span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">pi</span> <span class="o">*</span> <span class="n">char_sum</span><span class="p">)</span>
        <span class="c1">#print(&quot;f = &quot;, f)</span>
        <span class="nb">max</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="c1"># Evaluate the derivatives of the sigma function</span>
    <span class="n">s1</span> <span class="o">=</span> <span class="n">sigma1</span><span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="n">riemannM</span><span class="p">,</span> <span class="nb">max</span><span class="p">)</span>
    <span class="n">s2</span> <span class="o">=</span> <span class="n">sigma2</span><span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="n">riemannM</span><span class="p">,</span> <span class="nb">max</span><span class="p">)</span>
    <span class="n">u</span> <span class="o">=</span> <span class="o">-</span> <span class="p">((</span><span class="n">s1</span> <span class="o">*</span> <span class="n">periods_inverse</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">s2</span> <span class="o">*</span> <span class="n">periods_inverse</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span> <span class="o">/</span> <span class="p">(</span><span class="n">s1</span> <span class="o">*</span> <span class="n">periods_inverse</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">s2</span> <span class="o">*</span> <span class="n">periods_inverse</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]))</span>

    <span class="c1"># Check if u(initial_values[0]) is within the correct accuracy of initial_values[1] for the initial Newton method value</span>
    <span class="k">if</span> <span class="p">((</span><span class="n">initial_values</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">oo</span> <span class="ow">and</span> <span class="n">fabs</span><span class="p">(</span><span class="n">u</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="o">/</span><span class="n">eps</span><span class="o">*</span><span class="p">(</span><span class="mi">10</span><span class="o">**</span><span class="p">(</span><span class="o">-</span><span class="mi">4</span><span class="p">)))</span> <span class="ow">or</span> <span class="p">(</span><span class="n">initial_values</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">oo</span> <span class="ow">and</span> <span class="n">fabs</span><span class="p">(</span><span class="n">u</span> <span class="o">-</span> <span class="n">initial_values</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">&gt;</span> <span class="n">eps</span><span class="o">*</span><span class="mi">10</span><span class="o">**</span><span class="mi">4</span><span class="p">)):</span>
        <span class="nb">max</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">s1</span> <span class="o">=</span> <span class="n">sigma1</span><span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="n">riemannM</span><span class="p">,</span> <span class="nb">max</span><span class="p">)</span>
        <span class="n">s2</span> <span class="o">=</span> <span class="n">sigma2</span><span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="n">riemannM</span><span class="p">,</span> <span class="nb">max</span><span class="p">)</span>
        <span class="n">u</span> <span class="o">=</span> <span class="o">-</span> <span class="p">((</span><span class="n">s1</span> <span class="o">*</span> <span class="n">periods_inverse</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">s2</span> <span class="o">*</span> <span class="n">periods_inverse</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span> <span class="o">/</span> <span class="p">(</span><span class="n">s1</span> <span class="o">*</span> <span class="n">periods_inverse</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">s2</span> <span class="o">*</span> <span class="n">periods_inverse</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]))</span>
        <span class="k">if</span> <span class="p">((</span><span class="n">initial_values</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">oo</span> <span class="ow">and</span> <span class="n">fabs</span><span class="p">(</span><span class="n">u</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="o">/</span><span class="n">eps</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">initial_values</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">oo</span> <span class="ow">and</span> <span class="n">fabs</span><span class="p">(</span><span class="n">u</span> <span class="o">-</span> <span class="n">initial_values</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">&gt;</span> <span class="n">eps</span><span class="o">*</span><span class="mi">10</span><span class="o">**</span><span class="mi">4</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;u(</span><span class="si">{</span><span class="n">initial_values</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s2">) not close enough to u0 = </span><span class="si">{</span><span class="n">initial_values</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="si">}</span><span class="s2"> for x0 = </span><span class="si">{</span><span class="n">initNewton</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span> 
    
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Maximal summation index for Kleinian sigma function set to &quot;</span><span class="p">,</span> <span class="nb">max</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="nb">max</span></div>


<div class="viewcode-block" id="orbitdata">
<a class="viewcode-back" href="../../../geodesicparams.solvegeodesics.html#geodesicparams.solvegeodesics.solve_eom.orbitdata">[docs]</a>
<span class="k">def</span> <span class="nf">orbitdata</span><span class="p">(</span><span class="n">initial_values</span><span class="p">,</span> <span class="n">modified_init</span><span class="p">,</span> <span class="n">affine_list</span><span class="p">,</span> <span class="n">substitution</span><span class="p">,</span> <span class="n">initNewton</span><span class="p">,</span> <span class="n">eps</span><span class="p">,</span> <span class="n">minMax</span><span class="p">,</span> <span class="n">physical_comp</span><span class="p">,</span> <span class="n">datafile</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Organizes the solution calculations for a given &lt;affine_list&gt; of values. </span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    initial_values : list</span>
<span class="sd">        A list of initial values containing [gammain, xin] where gamma is the mino time and</span>
<span class="sd">        x is a spacetime coordinate.</span>
<span class="sd">    modified_init : complex</span>
<span class="sd">        A complex value = &lt;initial_values[1]&gt; + integration constant (computed by &lt;invert_eom&gt;)</span>
<span class="sd">    affine_list : list</span>
<span class="sd">        List of affine parameters / mino time values. </span>
<span class="sd">    substitution : callable</span>
<span class="sd">        The substitution used to cast the original equation of motion into its standard form. </span>
<span class="sd">    initNewton : complex</span>
<span class="sd">        The initial value of the Newton method. </span>
<span class="sd">    eps : float</span>
<span class="sd">        The accuracy of computation.</span>
<span class="sd">    minMax : int</span>
<span class="sd">        A natural number in the range 5 &lt;= minMax &lt;= 30 used to compute the summation bounds</span>
<span class="sd">        on the hyperelliptic theta and Kleinian sigma function.</span>
<span class="sd">    physical_comp</span>
<span class="sd">        An integer, either 1 or 0, representing the component of the theta divisor which</span>
<span class="sd">        corresponds to physical values (i.e. to the component of the vector of holomorphic</span>
<span class="sd">        differentials dz = [1/sqrt(P(z), z/sqrt(P(z))], where P(z) = &lt;polynomial&gt;).</span>
<span class="sd">    datafile : string, optional</span>
<span class="sd">        A file name to store information pertaining to the computation, such as the </span>
<span class="sd">        divisor list, coordinates, etc. This is optional, unlike solve_eom.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    list</span>
<span class="sd">        The solution values for the differential equation.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="k">global</span> <span class="n">periods_inverse</span><span class="p">,</span> <span class="n">riemannM</span>

    <span class="n">init_coord</span> <span class="o">=</span> <span class="n">initial_values</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">pos0</span> <span class="o">=</span> <span class="n">inlist</span><span class="p">(</span><span class="n">initial_values</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">affine_list</span><span class="p">)</span>

    <span class="c1"># Check if &lt;initial_values[0]&gt; is in affine_list</span>
    <span class="k">if</span> <span class="n">pos0</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Initial value </span><span class="si">{</span><span class="n">initial_values</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s2"> is not contained in list of affine parameters&quot;</span><span class="p">)</span>
    
    <span class="n">x</span> <span class="o">=</span> <span class="p">[</span><span class="n">initNewton</span><span class="p">];</span> <span class="n">coordinates</span> <span class="o">=</span> <span class="p">[</span><span class="n">init_coord</span><span class="p">];</span> <span class="n">subs_coord</span> <span class="o">=</span> <span class="p">[</span><span class="n">substitution</span><span class="p">(</span><span class="n">init_coord</span><span class="p">)]</span>

    <span class="k">if</span> <span class="n">physical_comp</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">divisor</span> <span class="o">=</span> <span class="p">[[</span><span class="o">-</span><span class="n">modified_init</span><span class="p">,</span> <span class="n">initNewton</span><span class="p">]]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">divisor</span> <span class="o">=</span> <span class="p">[[</span><span class="n">initNewton</span><span class="p">,</span> <span class="o">-</span><span class="n">modified_init</span><span class="p">]]</span>

    <span class="c1"># Compute solutions points past &lt;initial_values[0]&gt;</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Computing &quot;</span> <span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">affine_list</span><span class="p">)</span> <span class="o">-</span> <span class="n">pos0</span><span class="p">,</span> <span class="s2">&quot; solution points from i = &quot;</span><span class="p">,</span> <span class="n">pos0</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="s2">&quot; to &quot;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">affine_list</span><span class="p">),</span> <span class="s2">&quot; ...&quot;</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">pos0</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">affine_list</span><span class="p">)):</span>
        <span class="n">coord</span> <span class="o">=</span> <span class="n">solution</span><span class="p">(</span><span class="n">affine_list</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">modified_init</span><span class="p">,</span> <span class="n">x</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">eps</span><span class="p">,</span> <span class="n">minMax</span><span class="p">,</span> <span class="n">physical_comp</span><span class="p">)</span>
        <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>
        
        <span class="c1"># Try more computation iterations if the Newton method fails</span>
        <span class="k">while</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">coord</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span> <span class="ow">and</span> <span class="n">re</span><span class="p">(</span><span class="n">coord</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">&lt;</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">im</span><span class="p">(</span><span class="n">coord</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">&lt;</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">count</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">):</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Try more iterations ...&quot;</span><span class="p">)</span>
            <span class="n">coord</span> <span class="o">=</span> <span class="n">solution</span><span class="p">(</span><span class="n">affine_list</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">modified_init</span><span class="p">,</span> <span class="n">coord</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">eps</span><span class="p">,</span> <span class="n">minMax</span><span class="p">,</span> <span class="n">physical_comp</span><span class="p">)</span>
            <span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="c1"># Break if a point in &lt;affine_list&gt; could not be computed with &lt;solution&gt;</span>
        <span class="k">if</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">coord</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span> <span class="ow">and</span> <span class="n">im</span><span class="p">(</span><span class="n">coord</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">&lt;</span> <span class="mi">100</span> <span class="o">*</span> <span class="n">eps</span><span class="p">):</span>
            <span class="n">coordinates</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">re</span><span class="p">(</span><span class="n">coord</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
            <span class="n">subs_coord</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">substitution</span><span class="p">(</span><span class="n">re</span><span class="p">(</span><span class="n">coord</span><span class="p">[</span><span class="mi">0</span><span class="p">])))</span>
            <span class="n">x</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">coord</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">divisor</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">coord</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;WARNING in orbitdata: solution point for </span><span class="si">{</span><span class="n">affine_list</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="si">}</span><span class="s2"> (</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">. element) could not be computed result was </span><span class="si">{</span><span class="n">coord</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">break</span>

        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">i</span><span class="o">/</span><span class="mi">10</span><span class="p">)</span> <span class="o">==</span> <span class="nb">int</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot; ... &quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Computing &quot;</span><span class="p">,</span> <span class="n">pos0</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="s2">&quot; solution points from i = &quot;</span><span class="p">,</span> <span class="n">pos0</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="s2">&quot; to 0 ...&quot;</span><span class="p">)</span>
   
    <span class="c1"># Compute solution points before &lt;initial_values[0]&gt;</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">pos0</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
        <span class="n">coord</span> <span class="o">=</span> <span class="n">solution</span><span class="p">(</span><span class="n">affine_list</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">modified_init</span><span class="p">,</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">eps</span><span class="p">,</span> <span class="n">minMax</span><span class="p">,</span> <span class="n">physical_comp</span><span class="p">)</span>
        <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>
         
        <span class="c1"># Try more computation iterations if the Newton method fails </span>
        <span class="k">while</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">coord</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span> <span class="ow">and</span> <span class="n">re</span><span class="p">(</span><span class="n">coord</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">&lt;</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">im</span><span class="p">(</span><span class="n">coord</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">&lt;</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">count</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">):</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Try more iterations ...&quot;</span><span class="p">)</span>
            <span class="n">coord</span> <span class="o">=</span> <span class="n">solution</span><span class="p">(</span><span class="n">affine_list</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">modified_init</span><span class="p">,</span> <span class="n">coord</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">eps</span><span class="p">,</span> <span class="n">minMax</span><span class="p">,</span> <span class="n">physical_comp</span><span class="p">)</span>
            <span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span>
        
        <span class="c1"># Break if a point in &lt;affine_list&gt; could not be computed with &lt;solution&gt; </span>
        <span class="k">if</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">coord</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span> <span class="ow">and</span> <span class="n">im</span><span class="p">(</span><span class="n">coord</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">&lt;</span> <span class="mi">100</span> <span class="o">*</span> <span class="n">eps</span><span class="p">):</span>
            <span class="n">coordinates</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">re</span><span class="p">(</span><span class="n">coord</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
            <span class="n">subs_coord</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">substitution</span><span class="p">(</span><span class="n">re</span><span class="p">(</span><span class="n">coord</span><span class="p">[</span><span class="mi">0</span><span class="p">])))</span>
            <span class="n">x</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">coord</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">divisor</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">coord</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;WARNING in orbitdata: solution point for </span><span class="si">{</span><span class="n">affine_list</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="si">}</span><span class="s2"> (</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">. element) could not be computed.&quot;</span><span class="p">)</span>
            <span class="k">break</span>

        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">i</span><span class="o">/</span><span class="mi">10</span><span class="p">)</span> <span class="o">==</span> <span class="nb">int</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot; ... &quot;</span><span class="p">)</span>
    
    <span class="c1"># Save all lists to &lt;datafile&gt;.npy if provided</span>
    <span class="k">if</span> <span class="n">datafile</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">extended_orbitdata</span> <span class="o">=</span> <span class="n">array</span><span class="p">([[</span><span class="n">subs_coord</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">coordinates</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">x</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">divisor</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">affine_list</span><span class="p">[</span><span class="n">j</span><span class="p">]]</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">coordinates</span><span class="p">))],</span> <span class="n">dtype</span> <span class="o">=</span> <span class="nb">object</span><span class="p">)</span>
        <span class="n">save</span><span class="p">(</span><span class="n">datafile</span> <span class="o">+</span> <span class="s2">&quot;_orbitdata&quot;</span><span class="p">,</span> <span class="n">extended_orbitdata</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;extended orbitdata saved in </span><span class="si">{</span><span class="n">datafile</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="s1">&#39;_orbitdata&#39;</span><span class="si">}</span><span class="s2">.npy&quot;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">subs_coord</span></div>

 
<div class="viewcode-block" id="sigma_ln_numerical">
<a class="viewcode-back" href="../../../geodesicparams.solvegeodesics.html#geodesicparams.solvegeodesics.solve_eom.sigma_ln_numerical">[docs]</a>
<span class="k">def</span> <span class="nf">sigma_ln_numerical</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">omega1</span><span class="p">,</span> <span class="n">omega3</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Computes the value of ln(weierstrass_sigma(x - y) / weierstrass_sigma(x + y)) numerically.</span>

<span class="sd">    When the imaginary part of the result is 0, then the result becomes </span>
<span class="sd">    integral(weierstrass_zeta(x - y) - weierstrass_zeta(x + y), from 0 to x).</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x : complex</span>
<span class="sd">        A complex or real number.</span>
<span class="sd">    y : complex</span>
<span class="sd">        A potentially complex or real number.</span>
<span class="sd">    omega1 : complex</span>
<span class="sd">        The first half period in the period lattice.</span>
<span class="sd">    omega3 : complex</span>
<span class="sd">        The second half period in the period lattice.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    value : complex</span>
<span class="sd">        The result of the evaluated function.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">value</span> <span class="o">=</span> <span class="n">chop</span><span class="p">(</span><span class="n">log</span><span class="p">(</span><span class="n">weierstrass_sigma</span><span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="n">y</span><span class="p">,</span> <span class="n">omega1</span><span class="p">,</span> <span class="n">omega3</span><span class="p">)</span> <span class="o">/</span> <span class="n">weierstrass_sigma</span><span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">,</span> <span class="n">omega1</span><span class="p">,</span> <span class="n">omega3</span><span class="p">)))</span>

    <span class="k">if</span> <span class="n">im</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">value</span> <span class="o">=</span> <span class="n">chop</span><span class="p">(</span><span class="n">quad</span><span class="p">(</span><span class="k">lambda</span> <span class="n">s</span> <span class="p">:</span> <span class="n">weierstrass_zeta</span><span class="p">(</span><span class="n">s</span> <span class="o">-</span> <span class="n">y</span><span class="p">,</span> <span class="n">omega1</span><span class="p">,</span> <span class="n">omega3</span><span class="p">)</span> <span class="o">-</span> <span class="n">weierstrass_zeta</span><span class="p">(</span><span class="n">s</span> <span class="o">+</span> <span class="n">y</span><span class="p">,</span> <span class="n">omega1</span><span class="p">,</span> <span class="n">omega3</span><span class="p">),</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">x</span><span class="p">]))</span>

    <span class="k">return</span> <span class="n">value</span></div>


<div class="viewcode-block" id="sigma_ln">
<a class="viewcode-back" href="../../../geodesicparams.solvegeodesics.html#geodesicparams.solvegeodesics.solve_eom.sigma_ln">[docs]</a>
<span class="k">def</span> <span class="nf">sigma_ln</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">omega1</span><span class="p">,</span> <span class="n">omega3</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Computes the value of ln(weierstrass_sigma(x-y) / weierstrass_sigma(x+y)) while</span>
<span class="sd">    accounting the change in branches, ensuring the function remains continuous.</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x : list</span>
<span class="sd">        A list of numbers to be evaluated as a parameter.</span>
<span class="sd">    y : complex</span>
<span class="sd">        A potentially complex or real number.</span>
<span class="sd">    omega1 : complex</span>
<span class="sd">        The first half period in the period lattice.</span>
<span class="sd">    omega3 : complex</span>
<span class="sd">        The second half period in the period lattice.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    value : complex</span>
<span class="sd">        The result of the evaluated function.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">result</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">eta</span> <span class="o">=</span> <span class="n">periods_secondkind</span><span class="p">(</span><span class="n">omega1</span><span class="p">,</span> <span class="n">omega3</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

    <span class="c1"># Branch factor</span>
    <span class="n">c</span> <span class="o">=</span> <span class="n">sigma_ln_numerical</span><span class="p">(</span><span class="n">omega1</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">omega1</span><span class="p">,</span> <span class="n">omega3</span><span class="p">)</span> <span class="o">-</span> <span class="n">sigma_ln_numerical</span><span class="p">(</span><span class="mi">10</span><span class="o">**</span><span class="p">(</span><span class="o">-</span><span class="mi">10</span><span class="p">),</span> <span class="n">y</span><span class="p">,</span> <span class="n">omega1</span><span class="p">,</span> <span class="n">omega3</span><span class="p">)</span>
    <span class="n">branch</span> <span class="o">=</span> <span class="n">nint</span><span class="p">(</span><span class="n">chop</span><span class="p">(</span><span class="o">-</span><span class="n">omega1</span><span class="o">/</span><span class="p">(</span><span class="n">pi</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">im</span><span class="p">(</span><span class="n">c</span><span class="p">)</span><span class="o">/</span><span class="n">omega1</span> <span class="o">+</span> <span class="n">im</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">eta</span> <span class="o">*</span> <span class="n">y</span><span class="o">/</span><span class="n">omega1</span><span class="p">))))</span>
    <span class="n">switch</span> <span class="o">=</span> <span class="n">branch</span><span class="o">*</span><span class="n">pi</span><span class="o">*</span><span class="mi">1</span><span class="n">j</span>

    <span class="c1"># Evaluate function</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">x</span><span class="p">:</span>

        <span class="n">sigmatilde1</span> <span class="o">=</span> <span class="n">weierstrass_sigma</span><span class="p">(</span><span class="n">i</span> <span class="o">-</span> <span class="n">y</span><span class="p">,</span> <span class="n">omega1</span><span class="p">,</span> <span class="n">omega3</span><span class="p">)</span> <span class="o">*</span> <span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">eta</span> <span class="o">*</span> <span class="p">(</span><span class="n">i</span> <span class="o">-</span> <span class="n">y</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="o">/</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">omega1</span><span class="p">))</span>
        <span class="n">sigmatilde2</span> <span class="o">=</span> <span class="n">weierstrass_sigma</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="n">y</span><span class="p">,</span> <span class="n">omega1</span><span class="p">,</span> <span class="n">omega3</span><span class="p">)</span> <span class="o">*</span> <span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">eta</span> <span class="o">*</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="n">y</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="o">/</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">omega1</span><span class="p">))</span>
        
        <span class="n">value</span> <span class="o">=</span> <span class="n">log</span><span class="p">((</span><span class="n">sigmatilde1</span><span class="o">/</span><span class="n">sigmatilde2</span><span class="p">)</span> <span class="o">*</span> <span class="n">exp</span><span class="p">(</span><span class="n">switch</span> <span class="o">*</span> <span class="p">(</span><span class="n">i</span><span class="o">/</span><span class="n">omega1</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)))</span> <span class="o">-</span> <span class="n">switch</span> <span class="o">*</span> <span class="p">(</span><span class="n">i</span><span class="o">/</span><span class="n">omega1</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">eta</span><span class="o">*</span><span class="n">i</span> <span class="o">*</span> <span class="n">y</span><span class="o">/</span><span class="n">omega1</span>
        <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">result</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">result</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">result</span></div>


<div class="viewcode-block" id="integrate_elliptic_third">
<a class="viewcode-back" href="../../../geodesicparams.solvegeodesics.html#geodesicparams.solvegeodesics.solve_eom.integrate_elliptic_third">[docs]</a>
<span class="k">def</span> <span class="nf">integrate_elliptic_third</span><span class="p">(</span><span class="n">integrand</span><span class="p">,</span> <span class="n">datafile</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Computes the integral of 1 / (weierstrass(mino time) - pole)^n, where n is either 1 or 2</span>
<span class="sd">    (NOTE: n = 2 has not been implemented yet, tbd).</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    integrand : symbolic</span>
<span class="sd">        The integrand to be computed, containing a simple pole, or double pole (NOTE: double</span>
<span class="sd">        poles have yet to be implemented, tbd).</span>
<span class="sd">    datafile : string</span>
<span class="sd">        The name of the file containing the period matrix, elliptic invariants, initial</span>
<span class="sd">        values, etc.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    callable</span>
<span class="sd">        The function that computes the integration, taking a list of values or a single</span>
<span class="sd">        value as input (list is faster for more points than single).</span>

<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="c1"># Initial parameters</span>
    <span class="n">periods</span><span class="p">,</span> <span class="n">g2</span><span class="p">,</span> <span class="n">g3</span><span class="p">,</span> <span class="n">int_init</span><span class="p">,</span> <span class="n">inits</span> <span class="o">=</span> <span class="n">npload</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">datafile</span><span class="si">}</span><span class="s2">.npy&quot;</span><span class="p">,</span> <span class="n">allow_pickle</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span>
    <span class="n">mod_int</span> <span class="o">=</span> <span class="n">inits</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">int_init</span>
    <span class="n">coeff</span> <span class="o">=</span> <span class="n">integrand</span><span class="o">.</span><span class="n">as_numer_denom</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
    
    <span class="c1"># Locate the value v1 in the fundamental period parallelogram such that:</span>
    <span class="c1"># weierstrass_P(v1) = pole</span>
    <span class="n">inv_integrand</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">integrand</span>
    <span class="n">pole</span> <span class="o">=</span> <span class="n">solve</span><span class="p">(</span><span class="n">inv_integrand</span><span class="p">,</span> <span class="n">Poly</span><span class="p">(</span><span class="n">inv_integrand</span><span class="p">)</span><span class="o">.</span><span class="n">gen</span><span class="p">)</span>
    <span class="n">v1</span> <span class="o">=</span> <span class="n">inverse_weierstrass_P</span><span class="p">(</span><span class="n">pole</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">periods</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">periods</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

    <span class="c1"># Result function</span>
    <span class="k">def</span> <span class="nf">result</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>

        <span class="n">s_int</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="n">mod_int</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">s</span><span class="p">]</span>

        <span class="n">log_res</span> <span class="o">=</span> <span class="n">sigma_ln</span><span class="p">(</span><span class="n">s_int</span><span class="p">,</span> <span class="n">v1</span><span class="p">,</span> <span class="n">periods</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">periods</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">log_res0</span> <span class="o">=</span> <span class="n">sigma_ln</span><span class="p">([</span><span class="n">inits</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">mod_int</span><span class="p">],</span> <span class="n">v1</span><span class="p">,</span> <span class="n">periods</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">periods</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">type</span><span class="p">(</span><span class="n">log_res</span><span class="p">)</span> <span class="ow">in</span> <span class="p">[</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">]:</span>
            <span class="n">log_res</span> <span class="o">=</span> <span class="p">[</span><span class="n">log_res</span><span class="p">]</span>

        <span class="c1"># Solution to the integral</span>
        <span class="n">int_sol</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">s</span><span class="p">,</span> <span class="n">y</span> <span class="p">:</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">weierstrass_P</span><span class="p">(</span><span class="n">v1</span><span class="p">,</span> <span class="n">periods</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">periods</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">s</span> <span class="o">-</span> <span class="n">mod_int</span><span class="p">)</span> <span class="o">*</span> <span class="n">weierstrass_zeta</span><span class="p">(</span><span class="n">v1</span><span class="p">,</span> <span class="n">periods</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">periods</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">+</span> <span class="n">y</span><span class="p">)</span>

        <span class="c1"># Result</span>
        <span class="n">int_res0</span> <span class="o">=</span> <span class="n">int_sol</span><span class="p">(</span><span class="n">inits</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">log_res0</span><span class="p">)</span>
        <span class="n">sol</span> <span class="o">=</span> <span class="p">[</span><span class="n">coeff</span> <span class="o">*</span> <span class="p">(</span><span class="n">int_sol</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">log_res</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">-</span> <span class="n">int_res0</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">))]</span>
        <span class="k">return</span> <span class="n">sol</span>
    <span class="k">return</span> <span class="k">lambda</span> <span class="n">s</span> <span class="p">:</span> <span class="n">result</span><span class="p">(</span><span class="n">s</span><span class="p">)</span></div>


<div class="viewcode-block" id="compute_secondkind_periods">
<a class="viewcode-back" href="../../../geodesicparams.solvegeodesics.html#geodesicparams.solvegeodesics.solve_eom.compute_secondkind_periods">[docs]</a>
<span class="k">def</span> <span class="nf">compute_secondkind_periods</span><span class="p">(</span><span class="n">zeros</span><span class="p">,</span> <span class="n">eps</span><span class="p">,</span> <span class="n">periodMatrix</span><span class="p">,</span> <span class="n">datafile</span><span class="p">,</span> <span class="n">digits</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Computes the period matrices of the second kind for a genus 2 Riemann surface (i.e the </span>
<span class="sd">    integral of the vector of canonical meromorphic differentials along the contours </span>
<span class="sd">    connecting the branch cuts and the contours looping around the branch cuts).</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    zeros : list</span>
<span class="sd">        A list of complex or real numbers representing the zeros of the polynomial defining</span>
<span class="sd">        the genus 2 Riemann surface.</span>
<span class="sd">    eps : float</span>
<span class="sd">        A small error epsilon to handle divergence.</span>
<span class="sd">    periodMatrix : matrix</span>
<span class="sd">        A 2x4 matrix representing the periods of the first kind (integral of the vector of</span>
<span class="sd">        canonical holomorphic diffentials along the same contours above).</span>
<span class="sd">    datafile : string</span>
<span class="sd">        A string containing the name of a file to store the periods and epsilon error.</span>
<span class="sd">    digits : int</span>
<span class="sd">        The number of digits to be used in the computation.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    secondkindperiods : matrix</span>
<span class="sd">        A 2x4 matrix containing the period matrices of the second kind.</span>
<span class="sd">    r1 : list</span>
<span class="sd">        A list representing the coefficients of the first element of the vector of </span>
<span class="sd">        canonical meromorphic differentials.</span>
<span class="sd">    r2: list</span>
<span class="sd">        A list representing the coefficients of the second elment of the vector of </span>
<span class="sd">        canonical meromorphic differentials.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">x</span> <span class="o">=</span> <span class="n">Symbol</span><span class="p">(</span><span class="s2">&quot;x&quot;</span><span class="p">)</span>
    
    <span class="n">periodMatrix</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="n">periodMatrix</span><span class="p">)</span>

    <span class="n">omega1</span> <span class="o">=</span> <span class="n">periodMatrix</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">]</span>
    <span class="n">omega2</span> <span class="o">=</span> <span class="n">periodMatrix</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">:</span><span class="mi">4</span><span class="p">]</span>

    <span class="n">p</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="n">zeros</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">*</span> <span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="n">zeros</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">*</span> <span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="n">zeros</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span> <span class="o">*</span> <span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="n">zeros</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span> <span class="o">*</span> <span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="n">zeros</span><span class="p">[</span><span class="mi">4</span><span class="p">])</span>
    <span class="n">p</span> <span class="o">=</span> <span class="n">collect</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">expand</span><span class="p">(),</span> <span class="n">x</span><span class="p">)</span>

    <span class="n">coeffsP</span> <span class="o">=</span> <span class="p">[</span><span class="n">re</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">coeff</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">i</span><span class="p">))</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">6</span><span class="p">)]</span>

    <span class="c1"># Meromorphic differential coefficients</span>
    <span class="n">r1</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="o">/</span><span class="mi">4</span> <span class="o">*</span> <span class="n">coeffsP</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="mi">1</span><span class="o">/</span><span class="mi">2</span> <span class="o">*</span> <span class="n">coeffsP</span><span class="p">[</span><span class="mi">4</span><span class="p">],</span> <span class="mi">3</span><span class="o">/</span><span class="mi">4</span> <span class="o">*</span> <span class="n">coeffsP</span><span class="p">[</span><span class="mi">5</span><span class="p">]]</span>
    <span class="n">r2</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="o">/</span><span class="mi">4</span> <span class="o">*</span> <span class="n">coeffsP</span><span class="p">[</span><span class="mi">5</span><span class="p">]]</span>

    <span class="n">realNS</span><span class="p">,</span> <span class="n">complexNS</span> <span class="o">=</span> <span class="n">separate_zeros</span><span class="p">(</span><span class="n">zeros</span><span class="p">)</span>
    
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Computing second kind periods ...&quot;</span><span class="p">)</span>
    <span class="n">secondkindperiods</span> <span class="o">=</span> <span class="n">periods_second</span><span class="p">(</span><span class="n">r1</span><span class="p">,</span> <span class="n">r2</span><span class="p">,</span> <span class="n">realNS</span><span class="p">,</span> <span class="n">complexNS</span><span class="p">,</span> <span class="n">digits</span><span class="p">)</span>

    <span class="n">eta1</span> <span class="o">=</span> <span class="n">secondkindperiods</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">]</span>
    <span class="n">eta2</span> <span class="o">=</span> <span class="n">secondkindperiods</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">:</span><span class="mi">4</span><span class="p">]</span>

    <span class="n">m</span> <span class="o">=</span> <span class="n">eta2</span> <span class="o">*</span> <span class="n">eta1</span><span class="o">.</span><span class="n">T</span> <span class="o">-</span> <span class="n">eta1</span> <span class="o">*</span> <span class="n">eta2</span><span class="o">.</span><span class="n">T</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Legendre relation for periods of second kind = &quot;</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span>

    <span class="c1"># Check accuracy</span>
    <span class="k">if</span> <span class="n">fabs</span><span class="p">(</span><span class="n">m</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span> <span class="o">&gt;</span> <span class="n">eps</span> <span class="o">/</span> <span class="mi">10</span><span class="p">:</span>
        <span class="n">eps</span> <span class="o">=</span> <span class="n">fabs</span><span class="p">(</span><span class="n">m</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span> <span class="o">*</span> <span class="mi">10</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;WARNING in solve_hyperelliptic_third: accuracy further reduced to </span><span class="si">{</span><span class="n">eps</span><span class="si">}</span><span class="s2"> due to Legendre relation for periods of second kind&quot;</span><span class="p">)</span>

    <span class="n">m</span> <span class="o">=</span> <span class="n">omega2</span> <span class="o">*</span> <span class="n">eta1</span><span class="o">.</span><span class="n">T</span> <span class="o">-</span> <span class="n">omega1</span> <span class="o">*</span> <span class="n">eta2</span><span class="o">.</span><span class="n">T</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Mixed Legendre relation = &quot;</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">fabs</span><span class="p">(</span><span class="n">m</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span> <span class="o">&gt;</span> <span class="n">eps</span> <span class="o">/</span> <span class="mi">10</span> <span class="ow">or</span> <span class="n">fabs</span><span class="p">(</span><span class="n">m</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">pi</span><span class="o">/</span><span class="mi">2</span> <span class="o">*</span> <span class="mi">1</span><span class="n">j</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">eps</span> <span class="o">/</span> <span class="mi">10</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">fabs</span><span class="p">(</span><span class="n">m</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span> <span class="o">&gt;</span> <span class="n">fabs</span><span class="p">(</span><span class="n">m</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">pi</span><span class="o">/</span><span class="mi">2</span> <span class="o">*</span> <span class="mi">1</span><span class="n">j</span><span class="p">):</span>
            <span class="n">eps</span> <span class="o">=</span> <span class="n">fabs</span><span class="p">(</span><span class="n">m</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span> <span class="o">*</span> <span class="mi">10</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">eps</span> <span class="o">=</span> <span class="n">fabs</span><span class="p">(</span><span class="n">m</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">pi</span><span class="o">/</span><span class="mi">2</span> <span class="o">*</span> <span class="mi">1</span><span class="n">j</span><span class="p">)</span> <span class="o">*</span> <span class="mi">10</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;WARNING in solve_hyperelliptic_third: further reduced to </span><span class="si">{</span><span class="n">eps</span><span class="si">}</span><span class="s2"> due to relation between periods of first and second kind&quot;</span><span class="p">)</span>

    <span class="c1"># Save second kind periods and accuracy</span>
    <span class="n">save</span><span class="p">(</span><span class="n">datafile</span> <span class="o">+</span> <span class="s2">&quot;_secondkindperiods&quot;</span><span class="p">,</span> <span class="n">array</span><span class="p">([</span><span class="n">secondkindperiods</span><span class="o">.</span><span class="n">tolist</span><span class="p">(),</span> <span class="n">eps</span><span class="p">],</span> <span class="n">dtype</span> <span class="o">=</span> <span class="nb">object</span><span class="p">))</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Saved second kind period matrix to </span><span class="si">{</span><span class="n">datafile</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="s1">&#39;_secondkindperiods.npy&#39;</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">secondkindperiods</span><span class="p">,</span> <span class="n">r1</span><span class="p">,</span> <span class="n">r2</span></div>


<div class="viewcode-block" id="integrate_hyperelliptic_third">
<a class="viewcode-back" href="../../../geodesicparams.solvegeodesics.html#geodesicparams.solvegeodesics.solve_eom.integrate_hyperelliptic_third">[docs]</a>
<span class="k">def</span> <span class="nf">integrate_hyperelliptic_third</span><span class="p">(</span><span class="n">zeros</span><span class="p">,</span> <span class="n">r1</span><span class="p">,</span> <span class="n">r2</span><span class="p">,</span> <span class="n">eta</span><span class="p">,</span> <span class="n">integrand</span><span class="p">,</span> <span class="n">datafile</span><span class="p">,</span> <span class="n">digits</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Integrates a hyperelliptic integral of the third kind.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    zeros : list</span>
<span class="sd">        A list of complex or real numbers representing the zeros of the polynomial defining</span>
<span class="sd">        the genus 2 Riemann surface.</span>
<span class="sd">    r1 : list</span>
<span class="sd">        A list representing the coefficients of the first element of the vector of </span>
<span class="sd">        canonical meromorphic differentials.</span>
<span class="sd">    r2: list</span>
<span class="sd">        A list representing the coefficients of the second elment of the vector of </span>
<span class="sd">        canonical meromorphic differentials.</span>
<span class="sd">    eta : matrix</span>
<span class="sd">        A 2x2 matrix containing the first 2x2 part of the period matrix of the second kind.    </span>
<span class="sd">    integrand : symbolic</span>
<span class="sd">        The integrand containg the pole. </span>
<span class="sd">    datafile : string</span>
<span class="sd">        The name of the file (not including the . extension that is storing the periods of </span>
<span class="sd">        the second kind).</span>
<span class="sd">    digits : int</span>
<span class="sd">        The number of digits to be used in the computation.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    callable</span>
<span class="sd">        The solution function that performs the integration, taking in either a list of</span>
<span class="sd">        values or a single value (list of values is faster).</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">global</span> <span class="n">periods_inverse</span><span class="p">,</span> <span class="n">riemannM</span>
    <span class="n">periodMatrix</span><span class="p">,</span> <span class="n">invert_data</span><span class="p">,</span> <span class="n">eps</span> <span class="o">=</span> <span class="n">npload</span><span class="p">(</span><span class="n">datafile</span> <span class="o">+</span> <span class="s2">&quot;.npy&quot;</span><span class="p">,</span> <span class="n">allow_pickle</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span>

    <span class="c1"># Initial parameters</span>
    <span class="n">periodMatrix</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="n">periodMatrix</span><span class="p">)</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">Symbol</span><span class="p">(</span><span class="s2">&quot;x&quot;</span><span class="p">)</span> 
    <span class="n">init</span> <span class="o">=</span> <span class="n">invert_data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">s0</span> <span class="o">=</span> <span class="n">invert_data</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="nb">max</span> <span class="o">=</span> <span class="n">invert_data</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>

    <span class="n">periods_inverse</span><span class="p">,</span> <span class="n">riemannM</span> <span class="o">=</span> <span class="n">set_period_globals_genus2</span><span class="p">(</span><span class="n">periodMatrix</span><span class="p">)</span>

    <span class="c1"># Locate the pole</span>
    <span class="n">inv_integrand</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">integrand</span>
    <span class="n">pole</span> <span class="o">=</span> <span class="n">solve</span><span class="p">(</span><span class="n">inv_integrand</span><span class="p">,</span> <span class="n">Poly</span><span class="p">(</span><span class="n">inv_integrand</span><span class="p">)</span><span class="o">.</span><span class="n">gen</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

    <span class="n">p</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="n">zeros</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">*</span> <span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="n">zeros</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">*</span> <span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="n">zeros</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span> <span class="o">*</span> <span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="n">zeros</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span> <span class="o">*</span> <span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="n">zeros</span><span class="p">[</span><span class="mi">4</span><span class="p">])</span>
    <span class="n">p</span> <span class="o">=</span> <span class="n">collect</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">expand</span><span class="p">(),</span> <span class="n">x</span><span class="p">)</span>

    <span class="n">coeffsP</span> <span class="o">=</span> <span class="p">[</span><span class="n">re</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">coeff</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">i</span><span class="p">))</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">6</span><span class="p">)]</span>

    <span class="c1"># Check if integral is second kind</span>
    <span class="k">if</span> <span class="n">inlist</span><span class="p">(</span><span class="n">pole</span><span class="p">,</span> <span class="n">zeros</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Invalid use: integral is of second kind&quot;</span><span class="p">)</span>

    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Computing constants needed for solution hyperelliptic integral of third kind ...&quot;</span><span class="p">)</span>

    <span class="n">realNS</span><span class="p">,</span> <span class="n">complexNS</span> <span class="o">=</span> <span class="n">separate_zeros</span><span class="p">(</span><span class="n">zeros</span><span class="p">)</span>

    <span class="n">k</span> <span class="o">=</span> <span class="n">inlist</span><span class="p">(</span><span class="n">pole</span><span class="p">,</span> <span class="nb">sorted</span><span class="p">([</span><span class="n">pole</span><span class="p">]</span> <span class="o">+</span> <span class="n">zeros</span><span class="p">,</span> <span class="n">key</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span> <span class="p">:</span> <span class="n">re</span><span class="p">(</span><span class="n">x</span><span class="p">)))</span>

    <span class="k">if</span> <span class="n">k</span> <span class="o">&gt;</span> <span class="n">inlist</span><span class="p">(</span><span class="n">realNS</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">zeros</span><span class="p">)</span> <span class="ow">or</span> <span class="n">k</span> <span class="o">==</span> <span class="mi">4</span><span class="p">:</span> <span class="c1"># pole on realNS[-1]..oo</span>
        <span class="n">int_dz</span> <span class="o">=</span> <span class="n">myint_genus2</span><span class="p">(</span><span class="n">zeros</span><span class="p">,</span> <span class="n">pole</span><span class="p">,</span> <span class="n">realNS</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="mi">1</span><span class="p">,</span> <span class="n">digits</span><span class="p">)</span>
        <span class="n">int_2</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">myint_genus2_second</span><span class="p">(</span><span class="n">zeros</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">pole</span><span class="p">,</span> <span class="n">realNS</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="mi">1</span><span class="p">,</span> <span class="n">digits</span><span class="p">)</span>
        <span class="n">int_3</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">myint_genus2_second</span><span class="p">(</span><span class="n">zeros</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">pole</span><span class="p">,</span> <span class="n">realNS</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="mi">1</span><span class="p">,</span> <span class="n">digits</span><span class="p">)</span>
        <span class="n">inf1</span> <span class="o">=</span> <span class="n">eval_period</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">realNS</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">oo</span><span class="p">,</span> <span class="n">realNS</span><span class="p">,</span> <span class="n">zeros</span><span class="p">,</span> <span class="n">periodMatrix</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">inf2</span> <span class="o">=</span> <span class="n">eval_period</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">realNS</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">oo</span><span class="p">,</span> <span class="n">realNS</span><span class="p">,</span> <span class="n">zeros</span><span class="p">,</span> <span class="n">periodMatrix</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="c1"># in the remaining cases there is at least one real zero &gt; pole!</span>
    <span class="k">elif</span> <span class="n">k</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">im</span><span class="p">(</span><span class="n">zeros</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">int_dz</span> <span class="o">=</span> <span class="n">myint_genus2</span><span class="p">(</span><span class="n">zeros</span><span class="p">,</span> <span class="n">pole</span><span class="p">,</span> <span class="n">zeros</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="mi">1</span><span class="p">,</span> <span class="n">digits</span><span class="p">)</span>
            <span class="n">int_2</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">myint_genus2_second</span><span class="p">(</span><span class="n">zeros</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">pole</span><span class="p">,</span> <span class="n">zeros</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="mi">1</span><span class="p">,</span> <span class="n">digits</span><span class="p">)</span>
            <span class="n">int_3</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">myint_genus2_second</span><span class="p">(</span><span class="n">zeros</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">pole</span><span class="p">,</span> <span class="n">zeros</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="mi">1</span><span class="p">,</span> <span class="n">digits</span><span class="p">)</span>
            <span class="n">inf1</span> <span class="o">=</span> <span class="n">eval_period</span><span class="p">(</span><span class="n">inlist</span><span class="p">(</span><span class="n">zeros</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="n">realNS</span><span class="p">),</span> <span class="n">oo</span><span class="p">,</span> <span class="n">realNS</span><span class="p">,</span> <span class="n">zeros</span><span class="p">,</span> <span class="n">periodMatrix</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
            <span class="n">inf2</span> <span class="o">=</span> <span class="n">eval_period</span><span class="p">(</span><span class="n">inlist</span><span class="p">(</span><span class="n">zeros</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="n">realNS</span><span class="p">),</span> <span class="n">oo</span><span class="p">,</span> <span class="n">realNS</span><span class="p">,</span> <span class="n">zeros</span><span class="p">,</span> <span class="n">periodMatrix</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span> <span class="c1"># cases ima2Per3 and ima4Per1</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Case that the pole is located on a vertical branch cut is tbd&quot;</span><span class="p">)</span>
        
    <span class="k">elif</span> <span class="n">k</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">im</span><span class="p">(</span><span class="n">zeros</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">im</span><span class="p">(</span><span class="n">zeros</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">int_dz</span> <span class="o">=</span> <span class="n">myint_genus2</span><span class="p">(</span><span class="n">zeros</span><span class="p">,</span><span class="n">pole</span><span class="p">,</span><span class="n">zeros</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="mi">1</span><span class="p">,</span><span class="n">digits</span><span class="p">)</span>
            <span class="n">int_2</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">myint_genus2_second</span><span class="p">(</span><span class="n">zeros</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">pole</span><span class="p">,</span> <span class="n">zeros</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mi">1</span><span class="p">,</span> <span class="n">digits</span><span class="p">)</span>
            <span class="n">int_3</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">myint_genus2_second</span><span class="p">(</span><span class="n">zeros</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">pole</span><span class="p">,</span> <span class="n">zeros</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mi">1</span><span class="p">,</span> <span class="n">digits</span><span class="p">)</span>
            <span class="n">inf1</span> <span class="o">=</span> <span class="n">eval_period</span><span class="p">(</span><span class="n">inlist</span><span class="p">(</span><span class="n">zeros</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">realNS</span><span class="p">),</span> <span class="n">oo</span><span class="p">,</span> <span class="n">realNS</span><span class="p">,</span> <span class="n">zeros</span><span class="p">,</span> <span class="n">periodMatrix</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
            <span class="n">inf2</span> <span class="o">=</span> <span class="n">eval_period</span><span class="p">(</span><span class="n">inlist</span><span class="p">(</span><span class="n">zeros</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">realNS</span><span class="p">),</span> <span class="n">oo</span><span class="p">,</span> <span class="n">realNS</span><span class="p">,</span> <span class="n">zeros</span><span class="p">,</span> <span class="n">periodMatrix</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">im</span><span class="p">(</span><span class="n">zeros</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">im</span><span class="p">(</span><span class="n">zeros</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">int_dz</span> <span class="o">=</span> <span class="n">myint_genus2</span><span class="p">(</span><span class="n">zeros</span><span class="p">,</span> <span class="n">pole</span><span class="p">,</span> <span class="n">zeros</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="mi">1</span><span class="p">,</span> <span class="n">digits</span><span class="p">)</span>
            <span class="n">int_2</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">myint_genus2_second</span><span class="p">(</span><span class="n">zeros</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">pole</span><span class="p">,</span> <span class="n">zeros</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="mi">1</span><span class="p">,</span> <span class="n">digits</span><span class="p">)</span>
            <span class="n">int_3</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">myint_genus2_second</span><span class="p">(</span><span class="n">zeros</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">pole</span><span class="p">,</span> <span class="n">zeros</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="mi">1</span><span class="p">,</span> <span class="n">digits</span><span class="p">)</span>
            <span class="n">inf1</span> <span class="o">=</span> <span class="n">eval_period</span><span class="p">(</span><span class="n">inlist</span><span class="p">(</span><span class="n">zeros</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">realNS</span><span class="p">),</span> <span class="n">oo</span><span class="p">,</span> <span class="n">realNS</span><span class="p">,</span> <span class="n">zeros</span><span class="p">,</span> <span class="n">periodMatrix</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
            <span class="n">inf2</span> <span class="o">=</span> <span class="n">eval_period</span><span class="p">(</span><span class="n">inlist</span><span class="p">(</span><span class="n">zeros</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">realNS</span><span class="p">),</span> <span class="n">oo</span><span class="p">,</span> <span class="n">realNS</span><span class="p">,</span> <span class="n">zeros</span><span class="p">,</span> <span class="n">periodMatrix</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">pole</span> <span class="o">==</span> <span class="n">re</span><span class="p">(</span><span class="n">zeros</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
            <span class="n">int_dz</span> <span class="o">=</span> <span class="n">myint_genus2</span><span class="p">(</span><span class="n">zeros</span><span class="p">,</span> <span class="n">pole</span><span class="p">,</span> <span class="n">realNS</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">1</span><span class="p">,</span> <span class="n">digits</span><span class="p">)</span>
            <span class="n">int_2</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">myint_genus2_second</span><span class="p">(</span><span class="n">zeros</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">pole</span><span class="p">,</span> <span class="n">realNS</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">1</span><span class="p">,</span> <span class="n">digits</span><span class="p">)</span>
            <span class="n">int_3</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">myint_genus2_second</span><span class="p">(</span><span class="n">zeros</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">pole</span><span class="p">,</span> <span class="n">realNS</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">1</span><span class="p">,</span> <span class="n">digits</span><span class="p">)</span>
            <span class="n">inf1</span> <span class="o">=</span> <span class="n">eval_period</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">oo</span><span class="p">,</span> <span class="n">realNS</span><span class="p">,</span> <span class="n">zeros</span><span class="p">,</span> <span class="n">periodMatrix</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
            <span class="n">inf2</span> <span class="o">=</span> <span class="n">eval_period</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">oo</span><span class="p">,</span> <span class="n">realNS</span><span class="p">,</span> <span class="n">zeros</span><span class="p">,</span> <span class="n">periodMatrix</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span> <span class="c1"># ima4Per1 or ima4Per3</span>
            <span class="n">r</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">7</span><span class="p">):</span>
                <span class="n">r</span> <span class="o">+=</span> <span class="n">re</span><span class="p">(</span><span class="n">coeffsP</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">])</span> <span class="o">*</span> <span class="n">x</span><span class="o">**</span><span class="p">(</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">r</span> <span class="o">=</span> <span class="n">lambdify</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">r</span><span class="p">)</span>
            <span class="n">int_dz</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">([</span><span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">quad</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span> <span class="p">:</span> <span class="mi">1</span><span class="o">/</span><span class="n">sqrt</span><span class="p">(</span><span class="o">-</span><span class="n">r</span><span class="p">(</span><span class="n">x</span><span class="p">)),</span> <span class="p">[</span><span class="n">pole</span><span class="p">,</span> <span class="n">re</span><span class="p">(</span><span class="n">zeros</span><span class="p">[</span><span class="mi">1</span><span class="p">])]),</span>
                           <span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">quad</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span> <span class="p">:</span> <span class="n">x</span><span class="o">/</span><span class="n">sqrt</span><span class="p">(</span><span class="o">-</span><span class="n">r</span><span class="p">(</span><span class="n">x</span><span class="p">)),</span> <span class="p">[</span><span class="n">pole</span><span class="p">,</span> <span class="n">re</span><span class="p">(</span><span class="n">zeros</span><span class="p">[</span><span class="mi">1</span><span class="p">])])])</span>
            <span class="n">int_2</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">quad</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span> <span class="p">:</span> <span class="n">x</span><span class="o">**</span><span class="mi">2</span><span class="o">/</span><span class="n">sqrt</span><span class="p">(</span><span class="o">-</span><span class="n">r</span><span class="p">(</span><span class="n">x</span><span class="p">)),</span> <span class="p">[</span><span class="n">pole</span><span class="p">,</span> <span class="n">re</span><span class="p">(</span><span class="n">zeros</span><span class="p">[</span><span class="mi">1</span><span class="p">])])</span>
            <span class="n">int_3</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">quad</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span> <span class="p">:</span> <span class="n">x</span><span class="o">**</span><span class="mi">3</span><span class="o">/</span><span class="n">sqrt</span><span class="p">(</span><span class="o">-</span><span class="n">r</span><span class="p">(</span><span class="n">x</span><span class="p">)),</span> <span class="p">[</span><span class="n">pole</span><span class="p">,</span> <span class="n">re</span><span class="p">(</span><span class="n">zeros</span><span class="p">[</span><span class="mi">1</span><span class="p">])])</span>
            <span class="n">int_dz</span> <span class="o">+=</span> <span class="n">int_genus2_complex</span><span class="p">(</span><span class="n">zeros</span><span class="p">,</span> <span class="n">re</span><span class="p">(</span><span class="n">zeros</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="n">im</span><span class="p">(</span><span class="n">zeros</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">digits</span><span class="p">)</span>
            
            <span class="n">int_2</span> <span class="o">=</span> <span class="n">int_2</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">int_genus2_complex_second</span><span class="p">(</span><span class="n">zeros</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">re</span><span class="p">(</span><span class="n">zeros</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span>
            <span class="n">fabs</span><span class="p">(</span><span class="n">im</span><span class="p">(</span><span class="n">zeros</span><span class="p">[</span><span class="mi">0</span><span class="p">])),</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">digits</span><span class="p">)</span>
            
            <span class="n">int_3</span> <span class="o">+=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">int_genus2_complex_second</span><span class="p">(</span><span class="n">zeros</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">re</span><span class="p">(</span><span class="n">zeros</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span>
            <span class="n">fabs</span><span class="p">(</span><span class="n">im</span><span class="p">(</span><span class="n">zeros</span><span class="p">[</span><span class="mi">0</span><span class="p">])),</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">digits</span><span class="p">)</span>

            <span class="n">inf1</span> <span class="o">=</span> <span class="n">periodMatrix</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="n">periodMatrix</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
            <span class="n">inf2</span> <span class="o">=</span> <span class="n">periodMatrix</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="n">periodMatrix</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
            
    <span class="k">elif</span> <span class="n">k</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">im</span><span class="p">(</span><span class="n">zeros</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">int_dz</span> <span class="o">=</span> <span class="n">myint_genus2</span><span class="p">(</span><span class="n">zeros</span><span class="p">,</span> <span class="n">pole</span><span class="p">,</span> <span class="n">zeros</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">1</span><span class="p">,</span> <span class="n">digits</span><span class="p">)</span>
            <span class="n">int_2</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">myint_genus2_second</span><span class="p">(</span><span class="n">zeros</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">pole</span><span class="p">,</span> <span class="n">zeros</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">1</span><span class="p">,</span> <span class="n">digits</span><span class="p">)</span>
            <span class="n">int_3</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">myint_genus2_second</span><span class="p">(</span><span class="n">zeros</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">pole</span><span class="p">,</span> <span class="n">zeros</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">1</span><span class="p">,</span> <span class="n">digits</span><span class="p">)</span>
            <span class="n">inf1</span> <span class="o">=</span> <span class="n">eval_period</span><span class="p">(</span><span class="n">inlist</span><span class="p">(</span><span class="n">zeros</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">realNS</span><span class="p">),</span> <span class="n">oo</span><span class="p">,</span> <span class="n">realNS</span><span class="p">,</span> <span class="n">zeros</span><span class="p">,</span> <span class="n">periodMatrix</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
            <span class="n">inf2</span> <span class="o">=</span> <span class="n">eval_period</span><span class="p">(</span><span class="n">inlist</span><span class="p">(</span><span class="n">zeros</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">realNS</span><span class="p">),</span> <span class="n">oo</span><span class="p">,</span> <span class="n">realNS</span><span class="p">,</span> <span class="n">zeros</span><span class="p">,</span> <span class="n">periodMatrix</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span> <span class="c1"># cases ima2Per1, ima4Per1, and Ima4Per3</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Case that the pole is located on a vertical branch cut is tbd&quot;</span><span class="p">)</span>
            
    <span class="k">elif</span> <span class="n">k</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">im</span><span class="p">(</span><span class="n">zeros</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">im</span><span class="p">(</span><span class="n">zeros</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">int_dz</span> <span class="o">=</span> <span class="n">myint_genus2</span><span class="p">(</span><span class="n">zeros</span><span class="p">,</span> <span class="n">pole</span><span class="p">,</span> <span class="n">zeros</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">1</span><span class="p">,</span> <span class="n">digits</span><span class="p">)</span>
            <span class="n">int_2</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">myint_genus2_second</span><span class="p">(</span><span class="n">zeros</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">pole</span><span class="p">,</span> <span class="n">zeros</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">1</span><span class="p">,</span> <span class="n">digits</span><span class="p">)</span>
            <span class="n">int_3</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">myint_genus2_second</span><span class="p">(</span><span class="n">zeros</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">pole</span><span class="p">,</span> <span class="n">zeros</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">1</span><span class="p">,</span> <span class="n">digits</span><span class="p">)</span>
            <span class="n">inf1</span> <span class="o">=</span> <span class="n">eval_period</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">oo</span><span class="p">,</span> <span class="n">realNS</span><span class="p">,</span> <span class="n">zeros</span><span class="p">,</span> <span class="n">periodMatrix</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
            <span class="n">inf2</span> <span class="o">=</span> <span class="n">eval_period</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">oo</span><span class="p">,</span> <span class="n">realNS</span><span class="p">,</span> <span class="n">zeros</span><span class="p">,</span> <span class="n">periodMatrix</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">im</span><span class="p">(</span><span class="n">zeros</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">!=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">im</span><span class="p">(</span><span class="n">zeros</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">r</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">7</span><span class="p">):</span>
                <span class="n">r</span> <span class="o">+=</span> <span class="n">re</span><span class="p">(</span><span class="n">coeffsP</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">])</span> <span class="o">*</span> <span class="n">x</span><span class="o">**</span><span class="p">(</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">r</span> <span class="o">=</span> <span class="n">lambdify</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">r</span><span class="p">)</span>

            <span class="n">int_dz</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">([</span><span class="mi">1</span><span class="n">j</span><span class="o">*</span><span class="n">quad</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span> <span class="p">:</span> <span class="mi">1</span><span class="o">/</span><span class="n">sqrt</span><span class="p">(</span><span class="o">-</span><span class="n">r</span><span class="p">(</span><span class="n">x</span><span class="p">)),</span> <span class="p">[</span><span class="n">pole</span><span class="p">,</span> <span class="n">re</span><span class="p">(</span><span class="n">zeros</span><span class="p">[</span><span class="mi">0</span><span class="p">])]),</span>
                           <span class="mi">1</span><span class="n">j</span><span class="o">*</span><span class="n">quad</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span> <span class="p">:</span> <span class="n">x</span><span class="o">/</span><span class="n">sqrt</span><span class="p">(</span><span class="o">-</span><span class="n">r</span><span class="p">(</span><span class="n">x</span><span class="p">)),</span> <span class="p">[</span><span class="n">pole</span><span class="p">,</span> <span class="n">re</span><span class="p">(</span><span class="n">zeros</span><span class="p">[</span><span class="mi">0</span><span class="p">])])])</span>
            <span class="o">+</span> <span class="n">int_genus2_complex</span><span class="p">(</span><span class="n">zeros</span><span class="p">,</span> <span class="n">re</span><span class="p">(</span><span class="n">zeros</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">fabs</span><span class="p">(</span><span class="n">im</span><span class="p">(</span><span class="n">zeros</span><span class="p">[</span><span class="mi">0</span><span class="p">])),</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">digits</span><span class="p">)</span>

            <span class="n">int_2</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">quad</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span> <span class="p">:</span> <span class="n">x</span><span class="o">**</span><span class="mi">2</span><span class="o">/</span><span class="n">sqrt</span><span class="p">(</span><span class="o">-</span><span class="n">r</span><span class="p">(</span><span class="n">x</span><span class="p">)),</span> <span class="p">[</span><span class="n">pole</span><span class="p">,</span> <span class="n">re</span><span class="p">(</span><span class="n">zeros</span><span class="p">[</span><span class="mi">0</span><span class="p">])])</span>
            <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">int_genus2_complex_second</span><span class="p">(</span><span class="n">zeros</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">re</span><span class="p">(</span><span class="n">zeros</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">fabs</span><span class="p">(</span><span class="n">im</span><span class="p">(</span><span class="n">zeros</span><span class="p">[</span><span class="mi">0</span><span class="p">])),</span>
            <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">digits</span><span class="p">)</span>

            <span class="n">int_3</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">quad</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span> <span class="p">:</span> <span class="n">x</span><span class="o">**</span><span class="mi">3</span><span class="o">/</span><span class="n">sqrt</span><span class="p">(</span><span class="o">-</span><span class="n">r</span><span class="p">(</span><span class="n">x</span><span class="p">)),</span> <span class="p">[</span><span class="n">pole</span><span class="p">,</span> <span class="n">re</span><span class="p">(</span><span class="n">zeros</span><span class="p">[</span><span class="mi">0</span><span class="p">])])</span>
            <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">int_genus2_complex_second</span><span class="p">(</span><span class="n">zeros</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">re</span><span class="p">(</span><span class="n">zeros</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">fabs</span><span class="p">(</span><span class="n">im</span><span class="p">(</span><span class="n">zeros</span><span class="p">[</span><span class="mi">0</span><span class="p">])),</span>
            <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">digits</span><span class="p">)</span>

            <span class="n">inf1</span> <span class="o">=</span> <span class="n">periodMatrix</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="n">periodMatrix</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
            <span class="n">inf2</span> <span class="o">=</span> <span class="n">periodMatrix</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="n">periodMatrix</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">r</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">7</span><span class="p">):</span>
                <span class="n">r</span> <span class="o">+=</span> <span class="n">re</span><span class="p">(</span><span class="n">coeffsP</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">])</span> <span class="o">*</span> <span class="n">x</span><span class="o">**</span><span class="p">(</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">r</span> <span class="o">=</span> <span class="n">lambdify</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">r</span><span class="p">)</span>

            <span class="n">int_dz</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">([</span><span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">quad</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span> <span class="p">:</span> <span class="mi">1</span><span class="o">/</span><span class="n">sqrt</span><span class="p">(</span><span class="o">-</span><span class="n">r</span><span class="p">(</span><span class="n">x</span><span class="p">)),</span> <span class="p">[</span><span class="n">pole</span><span class="p">,</span> <span class="n">zeros</span><span class="p">[</span><span class="mi">0</span><span class="p">]]),</span>
            <span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">quad</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span> <span class="p">:</span> <span class="n">x</span><span class="o">/</span><span class="n">sqrt</span><span class="p">(</span><span class="o">-</span><span class="n">r</span><span class="p">(</span><span class="n">x</span><span class="p">)),</span> <span class="p">[</span><span class="n">pole</span><span class="p">,</span> <span class="n">zeros</span><span class="p">[</span><span class="mi">0</span><span class="p">]])])</span>
            <span class="o">+</span> <span class="n">myint_genus2</span><span class="p">(</span><span class="n">zeros</span><span class="p">,</span> <span class="n">zeros</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">re</span><span class="p">(</span><span class="n">zeros</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="mi">1</span><span class="p">,</span> <span class="n">digits</span><span class="p">)</span>
            <span class="o">+</span> <span class="n">int_genus2_complex</span><span class="p">(</span><span class="n">zeros</span><span class="p">,</span> <span class="n">re</span><span class="p">(</span><span class="n">zeros</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="n">fabs</span><span class="p">(</span><span class="n">im</span><span class="p">(</span><span class="n">zeros</span><span class="p">[</span><span class="mi">1</span><span class="p">])),</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">digits</span><span class="p">)</span>

            <span class="n">int_2</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">quad</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span> <span class="p">:</span> <span class="n">x</span><span class="o">**</span><span class="mi">2</span><span class="o">/</span><span class="n">sqrt</span><span class="p">(</span><span class="o">-</span><span class="n">r</span><span class="p">(</span><span class="n">x</span><span class="p">)),</span> <span class="p">[</span><span class="n">pole</span><span class="p">,</span> <span class="n">zeros</span><span class="p">[</span><span class="mi">0</span><span class="p">]])</span>
            <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">myint_genus2_second</span><span class="p">(</span><span class="n">zeros</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">zeros</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">re</span><span class="p">(</span><span class="n">zeros</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="mi">1</span><span class="p">,</span> <span class="n">digits</span><span class="p">)</span>
            <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">int_genus2_complex_second</span><span class="p">(</span><span class="n">zeros</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">re</span><span class="p">(</span><span class="n">zeros</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="n">fabs</span><span class="p">(</span><span class="n">im</span><span class="p">(</span><span class="n">zeros</span><span class="p">[</span><span class="mi">1</span><span class="p">])),</span>
            <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">digits</span><span class="p">)</span>

            <span class="n">int_3</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">quad</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span> <span class="p">:</span> <span class="n">x</span><span class="o">**</span><span class="mi">3</span><span class="o">/</span><span class="n">sqrt</span><span class="p">(</span><span class="o">-</span><span class="n">r</span><span class="p">(</span><span class="n">x</span><span class="p">)),</span> <span class="p">[</span><span class="n">pole</span><span class="p">,</span> <span class="n">zeros</span><span class="p">[</span><span class="mi">0</span><span class="p">]])</span>
            <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">myint_genus2_second</span><span class="p">(</span><span class="n">zeros</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">zeros</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">re</span><span class="p">(</span><span class="n">zeros</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="mi">1</span><span class="p">,</span> <span class="n">digits</span><span class="p">)</span>
            <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">int_genus2_complex_second</span><span class="p">(</span><span class="n">zeros</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">re</span><span class="p">(</span><span class="n">zeros</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="n">fabs</span><span class="p">(</span><span class="n">im</span><span class="p">(</span><span class="n">zeros</span><span class="p">[</span><span class="mi">1</span><span class="p">])),</span>
            <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">digits</span><span class="p">)</span>

            <span class="n">inf1</span> <span class="o">=</span> <span class="n">periodMatrix</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="n">periodMatrix</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
            <span class="n">inf2</span> <span class="o">=</span> <span class="n">periodMatrix</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="n">periodMatrix</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>

    <span class="c1"># Construct integrals of differentials</span>
    <span class="n">int_dr1</span> <span class="o">=</span> <span class="n">r1</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">int_dz</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">r1</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">*</span> <span class="n">int_2</span> <span class="o">+</span> <span class="n">r1</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">*</span> <span class="n">int_3</span> 
    <span class="n">int_dr2</span> <span class="o">=</span> <span class="n">r2</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">*</span> <span class="n">int_2</span>
    <span class="n">yi_inf</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">([</span><span class="n">int_dz</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">inf1</span><span class="p">,</span> <span class="n">int_dz</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">inf2</span><span class="p">])</span>
    <span class="n">xi_inf</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">([</span><span class="o">-</span><span class="n">int_dz</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">inf1</span><span class="p">,</span> <span class="o">-</span><span class="n">int_dz</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">inf2</span><span class="p">])</span>
    
    <span class="n">eta1</span> <span class="o">=</span> <span class="n">eta</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">]</span>
    <span class="n">kappa</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="mi">2</span> <span class="o">*</span> <span class="n">eta1</span> <span class="o">*</span> <span class="n">periods_inverse</span>

    <span class="c1"># Kleinian sigma function without exponential factor (may cause bad accuracy)</span>
    <span class="k">def</span> <span class="nf">sigma</span><span class="p">(</span><span class="n">z</span><span class="p">):</span>
        <span class="n">inverse_sum1</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">inverse_sum2</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">):</span>
            <span class="n">inverse_sum1</span> <span class="o">+=</span> <span class="n">periods_inverse</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">mpc</span><span class="p">(</span><span class="n">z</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="n">inverse_sum2</span> <span class="o">+=</span> <span class="n">periods_inverse</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">mpc</span><span class="p">(</span><span class="n">z</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>

        <span class="k">return</span> <span class="n">hyp_theta</span><span class="p">([</span><span class="mi">1</span><span class="o">/</span><span class="mi">2</span> <span class="o">*</span> <span class="n">inverse_sum1</span><span class="p">,</span> <span class="mi">1</span><span class="o">/</span><span class="mi">2</span> <span class="o">*</span> <span class="n">inverse_sum2</span><span class="p">],</span> <span class="n">riemannM</span><span class="p">,</span> <span class="nb">max</span><span class="p">)</span>

    <span class="c1"># Solution function</span>
    <span class="k">def</span> <span class="nf">result</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
        <span class="n">extended_orbitdata</span> <span class="o">=</span> <span class="n">npload</span><span class="p">(</span><span class="n">datafile</span> <span class="o">+</span> <span class="s2">&quot;_orbitdata.npy&quot;</span><span class="p">,</span> <span class="n">allow_pickle</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span>
        <span class="n">divisor</span> <span class="o">=</span> <span class="p">[</span><span class="n">extended_orbitdata</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">3</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">extended_orbitdata</span><span class="p">))]</span>
        <span class="n">affine_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">extended_orbitdata</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">4</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">extended_orbitdata</span><span class="p">))]</span>
        <span class="n">pos0</span> <span class="o">=</span> <span class="n">inlist</span><span class="p">(</span><span class="n">init</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">affine_list</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">pos0</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Position of initial value could not be located in list of affine parameters&quot;</span><span class="p">)</span>

        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Computing solution points ...&quot;</span><span class="p">)</span>
        <span class="n">const</span> <span class="o">=</span> <span class="p">((</span><span class="mi">2</span> <span class="o">*</span> <span class="n">matrix</span><span class="p">(</span><span class="n">divisor</span><span class="p">[</span><span class="n">pos0</span><span class="p">])</span><span class="o">.</span><span class="n">T</span> <span class="o">*</span> <span class="n">kappa</span> <span class="o">*</span> <span class="p">(</span><span class="n">xi_inf</span> <span class="o">-</span> <span class="n">yi_inf</span><span class="p">))</span> <span class="o">+</span> <span class="mi">1</span><span class="o">/</span><span class="mi">2</span> <span class="o">*</span> <span class="n">ln</span><span class="p">(</span><span class="n">sigma</span><span class="p">([</span><span class="n">divisor</span><span class="p">[</span><span class="n">pos0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">xi_inf</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">divisor</span><span class="p">[</span><span class="n">pos0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">xi_inf</span><span class="p">[</span><span class="mi">1</span><span class="p">]])</span>
        <span class="o">/</span> <span class="n">sigma</span><span class="p">([</span><span class="n">divisor</span><span class="p">[</span><span class="n">pos0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">yi_inf</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">divisor</span><span class="p">[</span><span class="n">pos0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">yi_inf</span><span class="p">[</span><span class="mi">1</span><span class="p">]])))[</span><span class="mi">0</span><span class="p">]</span>
        <span class="nb">vars</span> <span class="o">=</span> <span class="p">[</span><span class="n">sigma</span><span class="p">([</span><span class="n">divisor</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">xi_inf</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">divisor</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">xi_inf</span><span class="p">[</span><span class="mi">1</span><span class="p">]])</span> <span class="o">/</span> <span class="n">sigma</span><span class="p">([</span><span class="n">divisor</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">yi_inf</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">divisor</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">yi_inf</span><span class="p">[</span><span class="mi">1</span><span class="p">]])</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">divisor</span><span class="p">))]</span>
        <span class="n">log_vars</span> <span class="o">=</span> <span class="p">[(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">matrix</span><span class="p">(</span><span class="n">divisor</span><span class="p">[</span><span class="n">i</span><span class="p">])</span><span class="o">.</span><span class="n">T</span> <span class="o">*</span> <span class="n">kappa</span> <span class="o">*</span> <span class="p">(</span><span class="n">xi_inf</span> <span class="o">-</span> <span class="n">yi_inf</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">divisor</span><span class="p">))]</span>
        
        <span class="n">branch</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">res</span> <span class="o">=</span> <span class="p">[</span><span class="n">log_vars</span><span class="p">[</span><span class="n">pos0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="o">/</span><span class="mi">2</span> <span class="o">*</span> <span class="n">ln</span><span class="p">(</span><span class="nb">vars</span><span class="p">[</span><span class="n">pos0</span><span class="p">])</span> <span class="o">-</span> <span class="n">const</span> <span class="o">-</span> <span class="p">((</span><span class="n">divisor</span><span class="p">[</span><span class="n">pos0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">s0</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">*</span> <span class="n">int_dr1</span> <span class="o">+</span> <span class="p">(</span><span class="n">divisor</span><span class="p">[</span><span class="n">pos0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">s0</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">*</span> <span class="n">int_dr2</span><span class="p">)]</span>

        <span class="c1"># Compute solution points past the initial value in affine list</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">pos0</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">divisor</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">re</span><span class="p">(</span><span class="nb">vars</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">])</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">im</span><span class="p">(</span><span class="nb">vars</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">im</span><span class="p">(</span><span class="nb">vars</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">branch</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">elif</span> <span class="n">im</span><span class="p">(</span><span class="nb">vars</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">])</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">im</span><span class="p">(</span><span class="nb">vars</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">branch</span> <span class="o">-=</span> <span class="mi">1</span>
            <span class="n">res</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">log_vars</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="o">/</span><span class="mi">2</span> <span class="o">*</span> <span class="n">ln</span><span class="p">(</span><span class="nb">vars</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">+</span> <span class="p">(</span><span class="n">pi</span> <span class="o">*</span> <span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">branch</span><span class="p">)</span> <span class="o">-</span> <span class="n">const</span> <span class="o">-</span> <span class="p">((</span><span class="n">divisor</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">s0</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">*</span> <span class="n">int_dr1</span> <span class="o">+</span> <span class="p">(</span><span class="n">divisor</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">s0</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">*</span> <span class="n">int_dr2</span><span class="p">))</span>

        <span class="n">branch</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="c1"># Compute solution points before the initial value in affine list</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">pos0</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">re</span><span class="p">(</span><span class="nb">vars</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">im</span><span class="p">(</span><span class="nb">vars</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">im</span><span class="p">(</span><span class="nb">vars</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">branch</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">elif</span> <span class="n">im</span><span class="p">(</span><span class="nb">vars</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">im</span><span class="p">(</span><span class="nb">vars</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">branch</span> <span class="o">-=</span> <span class="mi">1</span>
            <span class="n">res</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">log_vars</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="o">/</span><span class="mi">2</span> <span class="o">*</span> <span class="n">ln</span><span class="p">(</span><span class="nb">vars</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">+</span> <span class="p">(</span><span class="n">pi</span> <span class="o">*</span> <span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">branch</span><span class="p">)</span> <span class="o">-</span> <span class="n">const</span> <span class="o">-</span> <span class="p">((</span><span class="n">divisor</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">s0</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">*</span> <span class="n">int_dr1</span> <span class="o">+</span> <span class="p">(</span><span class="n">divisor</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">s0</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">*</span> <span class="n">int_dr2</span><span class="p">))</span>
        
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">res</span><span class="p">)):</span>
            <span class="n">res</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">res</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">/</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">re</span><span class="p">(((</span><span class="n">pole</span> <span class="o">-</span> <span class="n">zeros</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">*</span> <span class="p">(</span><span class="n">pole</span> <span class="o">-</span> <span class="n">zeros</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">*</span> <span class="p">(</span><span class="n">pole</span> <span class="o">-</span> <span class="n">zeros</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span> <span class="o">*</span> <span class="p">(</span><span class="n">pole</span> <span class="o">-</span> <span class="n">zeros</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span> <span class="o">*</span> <span class="p">(</span><span class="n">pole</span> <span class="o">-</span> <span class="n">zeros</span><span class="p">[</span><span class="mi">4</span><span class="p">]))</span><span class="o">.</span><span class="n">evalf</span><span class="p">()))</span>
        <span class="k">return</span> <span class="n">res</span>

    <span class="k">return</span> <span class="k">lambda</span> <span class="n">s</span> <span class="p">:</span> <span class="n">result</span><span class="p">(</span><span class="n">s</span><span class="p">)</span></div>


<div class="viewcode-block" id="solution">
<a class="viewcode-back" href="../../../geodesicparams.solvegeodesics.html#geodesicparams.solvegeodesics.solve_eom.solution">[docs]</a>
<span class="k">def</span> <span class="nf">solution</span><span class="p">(</span><span class="n">affineParameter</span><span class="p">,</span> <span class="n">initNewton</span><span class="p">,</span> <span class="n">eps</span><span class="p">,</span> <span class="n">minMax</span><span class="p">,</span> <span class="n">physical_comp</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Computes the unphysical component of the theta divisor.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    affineParameter : complex</span>
<span class="sd">        The affine parameter gamma for which the solution for the hyperelliptic differential</span>
<span class="sd">        equation should be computed.</span>
<span class="sd">    initNewton : complex</span>
<span class="sd">        The initial value of the Newton method.</span>
<span class="sd">    eps : float</span>
<span class="sd">        The accuracy of the Newton method.</span>
<span class="sd">    minMax : int</span>
<span class="sd">        The summation bound for the hyperelliptic theta function.</span>
<span class="sd">    physical_comp : int</span>
<span class="sd">        An integer, either 1 or 0, representing the component of the theta divisor which</span>
<span class="sd">        corresponds to physical values (i.e. to the component of the vector of holomorphic</span>
<span class="sd">        differentials dz = [1/sqrt(P(z), z/sqrt(P(z))], where P(z) = &lt;polynomial&gt;).</span>
<span class="sd">        </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    list</span>
<span class="sd">        A list containing either two or three elements: if the Newton method failed, the list </span>
<span class="sd">        has two elements, where the first is a list of the steps taken by the iteration</span>
<span class="sd">        and the second the value of the theta function at the last iteration. If the iteration</span>
<span class="sd">        process was successful the list has three elements, where the first is the solution of</span>
<span class="sd">        the hyperelliptic differential equation at &lt;affineParameter&gt;, the second the redundant </span>
<span class="sd">        unphysical component of the theta divisor used to compute the first element,</span>
<span class="sd">        and the third (2*omega)*(the element of the thetadivisor used to compute the first</span>
<span class="sd">        element), where omega is the first 2x2 part of the period matrix of first kind.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">physical_comp</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">solution_first</span><span class="p">(</span><span class="n">affineParameter</span><span class="p">,</span> <span class="n">initNewton</span><span class="p">,</span> <span class="n">eps</span><span class="p">,</span> <span class="n">minMax</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">solution_second</span><span class="p">(</span><span class="n">affineParameter</span><span class="p">,</span> <span class="n">initNewton</span><span class="p">,</span> <span class="n">eps</span><span class="p">,</span> <span class="n">minMax</span><span class="p">)</span></div>


<div class="viewcode-block" id="solution_first">
<a class="viewcode-back" href="../../../geodesicparams.solvegeodesics.html#geodesicparams.solvegeodesics.solve_eom.solution_first">[docs]</a>
<span class="k">def</span> <span class="nf">solution_first</span><span class="p">(</span><span class="n">affineParameter</span><span class="p">,</span> <span class="n">initNewton</span><span class="p">,</span> <span class="n">eps</span><span class="p">,</span> <span class="n">minMax</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Computes the unphysical component of the theta divisor.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    affineParameter : complex</span>
<span class="sd">        The affine parameter gamma for which the solution for the hyperelliptic differential</span>
<span class="sd">        equation should be computed.</span>
<span class="sd">    initNewton : complex</span>
<span class="sd">        The initial value of the Newton method.</span>
<span class="sd">    eps : float</span>
<span class="sd">        The accuracy of the Newton method.</span>
<span class="sd">    minMax : int</span>
<span class="sd">        The summation bound for the hyperelliptic theta function.</span>
<span class="sd">        </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    list</span>
<span class="sd">        A list containing either two or three elements: if the Newton method failed, the list </span>
<span class="sd">        has two elements, where the first is a list of the steps taken by the iteration</span>
<span class="sd">        and the second the value of the theta function at the last iteration. If the iteration</span>
<span class="sd">        process was successful the list has three elements, where the first is the solution of</span>
<span class="sd">        the hyperelliptic differential equation at &lt;affineParameter&gt;, the second the redundant </span>
<span class="sd">        unphysical component of the theta divisor used to compute the first element,</span>
<span class="sd">        and the third (2*omega)*(the element of the thetadivisor used to compute the first</span>
<span class="sd">        element), where omega is the first 2x2 part of the period matrix of first kind.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">global</span> <span class="n">periods_inverse</span><span class="p">,</span> <span class="n">riemannM</span>

    <span class="c1"># Initial values</span>
    <span class="n">x</span> <span class="o">=</span> <span class="p">[</span><span class="n">initNewton</span><span class="p">]</span>
    <span class="n">zeroR</span> <span class="o">=</span> <span class="n">re</span><span class="p">(</span><span class="n">initNewton</span><span class="p">)</span>
    <span class="n">zeroI</span> <span class="o">=</span> <span class="n">im</span><span class="p">(</span><span class="n">initNewton</span><span class="p">)</span>

    <span class="n">affR</span> <span class="o">=</span> <span class="n">re</span><span class="p">(</span><span class="n">affineParameter</span><span class="p">)</span>
    <span class="n">affI</span> <span class="o">=</span> <span class="n">im</span><span class="p">(</span><span class="n">affineParameter</span><span class="p">)</span>

    <span class="n">perR</span> <span class="o">=</span> <span class="n">periods_inverse</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">re</span><span class="p">)</span>
    <span class="n">perI</span> <span class="o">=</span> <span class="n">periods_inverse</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">im</span><span class="p">)</span>

    <span class="n">p1</span> <span class="o">=</span> <span class="n">perR</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">affR</span> <span class="o">-</span> <span class="n">perI</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">affI</span>
    <span class="n">p2</span> <span class="o">=</span> <span class="n">perR</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">affI</span> <span class="o">+</span> <span class="n">perI</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">affR</span>
    <span class="n">p3</span> <span class="o">=</span> <span class="n">perR</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">affR</span> <span class="o">-</span> <span class="n">perI</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">affI</span>
    <span class="n">p4</span> <span class="o">=</span> <span class="n">perR</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">affI</span> <span class="o">+</span> <span class="n">perI</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">affR</span>

    <span class="n">zfirstR</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">perR</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">zeroR</span> <span class="o">-</span> <span class="n">perI</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">zeroI</span> <span class="o">+</span> <span class="n">p1</span><span class="p">)</span>
    <span class="n">zfirstI</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">perR</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">zeroI</span> <span class="o">+</span> <span class="n">perI</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">zeroR</span> <span class="o">+</span> <span class="n">p2</span><span class="p">)</span>
    <span class="n">zsecondR</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">perR</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">zeroR</span> <span class="o">-</span> <span class="n">perI</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">zeroI</span> <span class="o">+</span> <span class="n">p3</span><span class="p">)</span>
    <span class="n">zsecondI</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">perR</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">zeroI</span> <span class="o">+</span> <span class="n">perI</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">zeroR</span> <span class="o">+</span> <span class="n">p4</span><span class="p">)</span>

    <span class="n">z</span> <span class="o">=</span> <span class="p">[</span><span class="n">zfirstR</span> <span class="o">+</span> <span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">zfirstI</span><span class="p">,</span> <span class="n">zsecondR</span> <span class="o">+</span> <span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">zsecondI</span><span class="p">]</span>
    <span class="n">f</span> <span class="o">=</span> <span class="n">hyp_theta</span><span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="n">riemannM</span><span class="p">,</span> <span class="n">minMax</span><span class="p">)</span>
    <span class="n">af</span> <span class="o">=</span> <span class="n">fabs</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>

    <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="c1"># Begin Newton method</span>
    <span class="k">while</span> <span class="n">af</span> <span class="o">&gt;</span> <span class="n">eps</span> <span class="ow">and</span> <span class="n">count</span> <span class="o">&lt;</span> <span class="mi">30</span><span class="p">:</span>
        <span class="n">a</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">perR</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">hyp_theta_RR</span><span class="p">(</span><span class="n">zfirstR</span><span class="p">,</span> <span class="n">zfirstI</span><span class="p">,</span> <span class="n">zsecondR</span><span class="p">,</span> <span class="n">zsecondI</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">riemannM</span><span class="p">,</span> <span class="n">minMax</span><span class="p">)</span>
            <span class="o">-</span> <span class="n">perI</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">hyp_theta_IR</span><span class="p">(</span><span class="n">zfirstR</span><span class="p">,</span> <span class="n">zfirstI</span><span class="p">,</span> <span class="n">zsecondR</span><span class="p">,</span> <span class="n">zsecondI</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">riemannM</span><span class="p">,</span> <span class="n">minMax</span><span class="p">)</span>
            <span class="o">+</span> <span class="n">perR</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">hyp_theta_RR</span><span class="p">(</span><span class="n">zfirstR</span><span class="p">,</span> <span class="n">zfirstI</span><span class="p">,</span> <span class="n">zsecondR</span><span class="p">,</span> <span class="n">zsecondI</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">riemannM</span><span class="p">,</span> <span class="n">minMax</span><span class="p">)</span>
            <span class="o">-</span> <span class="n">perI</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">hyp_theta_IR</span><span class="p">(</span><span class="n">zfirstR</span><span class="p">,</span> <span class="n">zfirstI</span><span class="p">,</span> <span class="n">zsecondR</span><span class="p">,</span> <span class="n">zsecondI</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">riemannM</span><span class="p">,</span> <span class="n">minMax</span><span class="p">))</span>
        <span class="n">c</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">perR</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">hyp_theta_IR</span><span class="p">(</span><span class="n">zfirstR</span><span class="p">,</span> <span class="n">zfirstI</span><span class="p">,</span> <span class="n">zsecondR</span><span class="p">,</span> <span class="n">zsecondI</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">riemannM</span><span class="p">,</span> <span class="n">minMax</span><span class="p">)</span>
            <span class="o">+</span> <span class="n">perI</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">hyp_theta_RR</span><span class="p">(</span><span class="n">zfirstR</span><span class="p">,</span> <span class="n">zfirstI</span><span class="p">,</span> <span class="n">zsecondR</span><span class="p">,</span> <span class="n">zsecondI</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">riemannM</span><span class="p">,</span> <span class="n">minMax</span><span class="p">)</span>
            <span class="o">+</span> <span class="n">perR</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">hyp_theta_IR</span><span class="p">(</span><span class="n">zfirstR</span><span class="p">,</span> <span class="n">zfirstI</span><span class="p">,</span> <span class="n">zsecondR</span><span class="p">,</span> <span class="n">zsecondI</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">riemannM</span><span class="p">,</span> <span class="n">minMax</span><span class="p">)</span>
            <span class="o">+</span> <span class="n">perI</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">hyp_theta_RR</span><span class="p">(</span><span class="n">zfirstR</span><span class="p">,</span> <span class="n">zfirstI</span><span class="p">,</span> <span class="n">zsecondR</span><span class="p">,</span> <span class="n">zsecondI</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">riemannM</span><span class="p">,</span> <span class="n">minMax</span><span class="p">))</span>
        
        <span class="n">b</span> <span class="o">=</span> <span class="o">-</span><span class="n">c</span><span class="p">;</span> <span class="n">d</span> <span class="o">=</span> <span class="n">a</span>
        <span class="n">det</span> <span class="o">=</span> <span class="n">a</span><span class="o">*</span><span class="n">d</span> <span class="o">-</span> <span class="n">b</span><span class="o">*</span><span class="n">c</span>

        <span class="n">zeroR</span> <span class="o">=</span> <span class="n">zeroR</span> <span class="o">-</span> <span class="mi">1</span><span class="o">/</span><span class="n">det</span> <span class="o">*</span> <span class="p">(</span><span class="n">d</span><span class="o">*</span><span class="n">re</span><span class="p">(</span><span class="n">f</span><span class="p">)</span> <span class="o">-</span> <span class="n">b</span><span class="o">*</span><span class="n">im</span><span class="p">(</span><span class="n">f</span><span class="p">))</span>
        <span class="n">zeroI</span> <span class="o">=</span> <span class="n">zeroI</span> <span class="o">-</span> <span class="mi">1</span><span class="o">/</span><span class="n">det</span> <span class="o">*</span> <span class="p">(</span><span class="o">-</span><span class="n">c</span><span class="o">*</span><span class="n">re</span><span class="p">(</span><span class="n">f</span><span class="p">)</span> <span class="o">+</span> <span class="n">a</span><span class="o">*</span><span class="n">im</span><span class="p">(</span><span class="n">f</span><span class="p">))</span>
        <span class="n">zero</span> <span class="o">=</span> <span class="n">zeroR</span> <span class="o">+</span> <span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">zeroI</span>
        <span class="n">x</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">zero</span><span class="p">)</span>
        
        <span class="c1"># Update z and f</span>
        <span class="n">zfirstR</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">perR</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">zeroR</span> <span class="o">-</span> <span class="n">perI</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">zeroI</span> <span class="o">+</span> <span class="n">p1</span><span class="p">)</span>
        <span class="n">zfirstI</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">perR</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">zeroI</span> <span class="o">+</span> <span class="n">perI</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">zeroR</span> <span class="o">+</span> <span class="n">p2</span><span class="p">)</span>
        <span class="n">zsecondR</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">perR</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">zeroR</span> <span class="o">-</span> <span class="n">perI</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">zeroI</span> <span class="o">+</span> <span class="n">p3</span><span class="p">)</span>
        <span class="n">zsecondI</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">perR</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">zeroI</span> <span class="o">+</span> <span class="n">perI</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">zeroR</span> <span class="o">+</span> <span class="n">p4</span><span class="p">)</span>
        <span class="n">z</span> <span class="o">=</span> <span class="p">[</span><span class="n">zfirstR</span> <span class="o">+</span> <span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">zfirstI</span><span class="p">,</span> <span class="n">zsecondR</span> <span class="o">+</span> <span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">zsecondI</span><span class="p">]</span>
        <span class="n">f</span> <span class="o">=</span> <span class="n">hyp_theta</span><span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="n">riemannM</span><span class="p">,</span> <span class="n">minMax</span><span class="p">)</span>
        <span class="n">af</span> <span class="o">=</span> <span class="n">fabs</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
        <span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span>
        
    <span class="c1"># If Newton method fails to converge within a givin accuracy</span>
    <span class="k">if</span> <span class="n">af</span> <span class="o">&gt;</span> <span class="n">eps</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;In solution: Iteration process stopped after 30 iterations.&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;hyp_theta(1/2 * omega1inv * (phi, initNewton)^t) = &quot;</span><span class="p">,</span> <span class="n">f</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="n">f</span><span class="p">]</span>

    <span class="c1"># Evaluate solution at the affine parameter</span>
    <span class="n">s1</span> <span class="o">=</span> <span class="n">sigma1</span><span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="n">riemannM</span><span class="p">,</span> <span class="n">minMax</span><span class="p">)</span>
    <span class="n">s2</span> <span class="o">=</span> <span class="n">sigma2</span><span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="n">riemannM</span><span class="p">,</span> <span class="n">minMax</span><span class="p">)</span>
    <span class="n">sol</span> <span class="o">=</span> <span class="o">-</span> <span class="p">((</span><span class="n">s1</span> <span class="o">*</span> <span class="n">periods_inverse</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">s2</span> <span class="o">*</span> <span class="n">periods_inverse</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span> <span class="o">/</span> <span class="p">(</span><span class="n">s1</span> <span class="o">*</span> <span class="n">periods_inverse</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">s2</span> <span class="o">*</span> <span class="n">periods_inverse</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]))</span>
    
    <span class="k">return</span> <span class="p">[</span><span class="n">sol</span><span class="p">,</span> <span class="n">x</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="n">affineParameter</span><span class="p">,</span> <span class="n">x</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]]]</span></div>


<div class="viewcode-block" id="solution_second">
<a class="viewcode-back" href="../../../geodesicparams.solvegeodesics.html#geodesicparams.solvegeodesics.solve_eom.solution_second">[docs]</a>
<span class="k">def</span> <span class="nf">solution_second</span><span class="p">(</span><span class="n">affineParameter</span><span class="p">,</span> <span class="n">initNewton</span><span class="p">,</span> <span class="n">eps</span><span class="p">,</span> <span class="n">minMax</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Computes the unphysical component of the theta divisor.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    affineParameter : complex</span>
<span class="sd">        The affine parameter gamma for which the solution for the hyperelliptic differential</span>
<span class="sd">        equation should be computed.</span>
<span class="sd">    initNewton : complex</span>
<span class="sd">        The initial value of the Newton method.</span>
<span class="sd">    eps : float</span>
<span class="sd">        The accuracy of the Newton method.</span>
<span class="sd">    minMax : int</span>
<span class="sd">        The summation bound for the hyperelliptic theta function.</span>
<span class="sd">        </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    list</span>
<span class="sd">        A list containing either two or three elements: if the Newton method failed, the list </span>
<span class="sd">        has two elements, where the first is a list of the steps taken by the iteration</span>
<span class="sd">        and the second the value of the theta function at the last iteration. If the iteration</span>
<span class="sd">        process was successful the list has three elements, where the first is the solution of</span>
<span class="sd">        the hyperelliptic differential equation at &lt;affineParameter&gt;, the second the redundant </span>
<span class="sd">        unphysical component of the theta divisor used to compute the first element,</span>
<span class="sd">        and the third (2*omega)*(the element of the thetadivisor used to compute the first</span>
<span class="sd">        element), where omega is the first 2x2 part of the period matrix of first kind.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">global</span> <span class="n">periods_inverse</span><span class="p">,</span> <span class="n">riemannM</span>

    <span class="c1"># Initial values</span>
    <span class="n">x</span> <span class="o">=</span> <span class="p">[</span><span class="n">initNewton</span><span class="p">]</span>
    <span class="n">zeroR</span> <span class="o">=</span> <span class="n">re</span><span class="p">(</span><span class="n">initNewton</span><span class="p">)</span>
    <span class="n">zeroI</span> <span class="o">=</span> <span class="n">im</span><span class="p">(</span><span class="n">initNewton</span><span class="p">)</span>

    <span class="n">affR</span> <span class="o">=</span> <span class="n">re</span><span class="p">(</span><span class="n">affineParameter</span><span class="p">)</span>
    <span class="n">affI</span> <span class="o">=</span> <span class="n">im</span><span class="p">(</span><span class="n">affineParameter</span><span class="p">)</span>

    <span class="n">perR</span> <span class="o">=</span> <span class="n">periods_inverse</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">re</span><span class="p">)</span>
    <span class="n">perI</span> <span class="o">=</span> <span class="n">periods_inverse</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">im</span><span class="p">)</span>

    <span class="n">p1</span> <span class="o">=</span> <span class="n">perR</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">affR</span> <span class="o">-</span> <span class="n">perI</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">affI</span>
    <span class="n">p2</span> <span class="o">=</span> <span class="n">perR</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">affI</span> <span class="o">+</span> <span class="n">perI</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">affR</span>
    <span class="n">p3</span> <span class="o">=</span> <span class="n">perR</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">affR</span> <span class="o">-</span> <span class="n">perI</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">affI</span>
    <span class="n">p4</span> <span class="o">=</span> <span class="n">perR</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">affI</span> <span class="o">+</span> <span class="n">perI</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">affR</span>

    <span class="n">zfirstR</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">perR</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">zeroR</span> <span class="o">-</span> <span class="n">perI</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">zeroI</span> <span class="o">+</span> <span class="n">p1</span><span class="p">)</span>
    <span class="n">zfirstI</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">perR</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">zeroI</span> <span class="o">+</span> <span class="n">perI</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">zeroR</span> <span class="o">+</span> <span class="n">p2</span><span class="p">)</span>
    <span class="n">zsecondR</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">perR</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">zeroR</span> <span class="o">-</span> <span class="n">perI</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">zeroI</span> <span class="o">+</span> <span class="n">p3</span><span class="p">)</span>
    <span class="n">zsecondI</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">perR</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">zeroI</span> <span class="o">+</span> <span class="n">perI</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">zeroR</span> <span class="o">+</span> <span class="n">p4</span><span class="p">)</span>

    <span class="n">z</span> <span class="o">=</span> <span class="p">[</span><span class="n">zfirstR</span> <span class="o">+</span> <span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">zfirstI</span><span class="p">,</span> <span class="n">zsecondR</span> <span class="o">+</span> <span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">zsecondI</span><span class="p">]</span>
    <span class="n">f</span> <span class="o">=</span> <span class="n">hyp_theta</span><span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="n">riemannM</span><span class="p">,</span> <span class="n">minMax</span><span class="p">)</span>
    <span class="n">af</span> <span class="o">=</span> <span class="n">fabs</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>

    <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>
    
    <span class="c1"># Begin Newton method</span>
    <span class="k">while</span> <span class="n">af</span> <span class="o">&gt;</span> <span class="n">eps</span> <span class="ow">and</span> <span class="n">count</span> <span class="o">&lt;</span> <span class="mi">30</span><span class="p">:</span>
        <span class="n">a</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">perR</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">hyp_theta_RR</span><span class="p">(</span><span class="n">zfirstR</span><span class="p">,</span> <span class="n">zfirstI</span><span class="p">,</span> <span class="n">zsecondR</span><span class="p">,</span> <span class="n">zsecondI</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">riemannM</span><span class="p">,</span> <span class="n">minMax</span><span class="p">)</span>
            <span class="o">-</span> <span class="n">perI</span><span class="p">[</span><span class="mi">0</span> <span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">hyp_theta_IR</span><span class="p">(</span><span class="n">zfirstR</span><span class="p">,</span> <span class="n">zfirstI</span><span class="p">,</span> <span class="n">zsecondR</span><span class="p">,</span> <span class="n">zsecondI</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">riemannM</span><span class="p">,</span> <span class="n">minMax</span><span class="p">)</span>
            <span class="o">+</span> <span class="n">perR</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">hyp_theta_RR</span><span class="p">(</span><span class="n">zfirstR</span><span class="p">,</span> <span class="n">zfirstI</span><span class="p">,</span> <span class="n">zsecondR</span><span class="p">,</span> <span class="n">zsecondI</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">riemannM</span><span class="p">,</span> <span class="n">minMax</span><span class="p">)</span>
            <span class="o">-</span> <span class="n">perI</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">hyp_theta_IR</span><span class="p">(</span><span class="n">zfirstR</span><span class="p">,</span> <span class="n">zfirstI</span><span class="p">,</span> <span class="n">zsecondR</span><span class="p">,</span> <span class="n">zsecondI</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">riemannM</span><span class="p">,</span> <span class="n">minMax</span><span class="p">))</span>
        <span class="n">c</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">perR</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">hyp_theta_IR</span><span class="p">(</span><span class="n">zfirstR</span><span class="p">,</span> <span class="n">zfirstI</span><span class="p">,</span> <span class="n">zsecondR</span><span class="p">,</span> <span class="n">zsecondI</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">riemannM</span><span class="p">,</span> <span class="n">minMax</span><span class="p">)</span>
            <span class="o">+</span> <span class="n">perI</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">hyp_theta_RR</span><span class="p">(</span><span class="n">zfirstR</span><span class="p">,</span> <span class="n">zfirstI</span><span class="p">,</span> <span class="n">zsecondR</span><span class="p">,</span> <span class="n">zsecondI</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">riemannM</span><span class="p">,</span> <span class="n">minMax</span><span class="p">)</span>
            <span class="o">+</span> <span class="n">perR</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">hyp_theta_IR</span><span class="p">(</span><span class="n">zfirstR</span><span class="p">,</span> <span class="n">zfirstI</span><span class="p">,</span> <span class="n">zsecondR</span><span class="p">,</span> <span class="n">zsecondI</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">riemannM</span><span class="p">,</span> <span class="n">minMax</span><span class="p">)</span>
            <span class="o">+</span> <span class="n">perI</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">hyp_theta_RR</span><span class="p">(</span><span class="n">zfirstR</span><span class="p">,</span> <span class="n">zfirstI</span><span class="p">,</span> <span class="n">zsecondR</span><span class="p">,</span> <span class="n">zsecondI</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">riemannM</span><span class="p">,</span> <span class="n">minMax</span><span class="p">))</span>
        <span class="n">b</span> <span class="o">=</span> <span class="o">-</span><span class="n">c</span><span class="p">;</span> <span class="n">d</span> <span class="o">=</span> <span class="n">a</span>
        <span class="n">det</span> <span class="o">=</span> <span class="n">a</span><span class="o">*</span><span class="n">d</span> <span class="o">-</span> <span class="n">b</span><span class="o">*</span><span class="n">c</span>

        <span class="n">zeroR</span> <span class="o">=</span> <span class="n">zeroR</span> <span class="o">-</span> <span class="mi">1</span><span class="o">/</span><span class="n">det</span><span class="o">*</span><span class="p">(</span><span class="n">d</span><span class="o">*</span><span class="n">re</span><span class="p">(</span><span class="n">f</span><span class="p">)</span> <span class="o">-</span> <span class="n">b</span><span class="o">*</span><span class="n">im</span><span class="p">(</span><span class="n">f</span><span class="p">))</span>
        <span class="n">zeroI</span> <span class="o">=</span> <span class="n">zeroI</span> <span class="o">-</span> <span class="mi">1</span><span class="o">/</span><span class="n">det</span><span class="o">*</span><span class="p">(</span><span class="o">-</span><span class="n">c</span><span class="o">*</span><span class="n">re</span><span class="p">(</span><span class="n">f</span><span class="p">)</span> <span class="o">+</span> <span class="n">a</span><span class="o">*</span><span class="n">im</span><span class="p">(</span><span class="n">f</span><span class="p">))</span>
        <span class="n">zero</span> <span class="o">=</span> <span class="n">zeroR</span> <span class="o">+</span> <span class="mi">1</span><span class="n">j</span><span class="o">*</span><span class="n">zeroI</span>
        <span class="n">x</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">zero</span><span class="p">)</span>
        
        <span class="c1"># Update z and f</span>
        <span class="n">zfirstR</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">perR</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">zeroR</span> <span class="o">-</span> <span class="n">perI</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">zeroI</span> <span class="o">+</span> <span class="n">p1</span><span class="p">)</span>
        <span class="n">zfirstI</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">perR</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">zeroI</span> <span class="o">+</span> <span class="n">perI</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">zeroR</span> <span class="o">+</span> <span class="n">p2</span><span class="p">)</span>
        <span class="n">zsecondR</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">perR</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">zeroR</span> <span class="o">-</span> <span class="n">perI</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">zeroI</span> <span class="o">+</span> <span class="n">p3</span><span class="p">)</span>
        <span class="n">zsecondI</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">perR</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">zeroI</span> <span class="o">+</span> <span class="n">perI</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">zeroR</span> <span class="o">+</span> <span class="n">p4</span><span class="p">)</span>
        <span class="n">z</span> <span class="o">=</span> <span class="p">[</span><span class="n">zfirstR</span> <span class="o">+</span> <span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">zfirstI</span><span class="p">,</span> <span class="n">zsecondR</span> <span class="o">+</span> <span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">zsecondI</span><span class="p">]</span>
        <span class="n">f</span> <span class="o">=</span> <span class="n">hyp_theta</span><span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="n">riemannM</span><span class="p">,</span> <span class="n">minMax</span><span class="p">)</span>
        <span class="n">af</span> <span class="o">=</span> <span class="n">fabs</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
        <span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span>
  
    <span class="c1"># If Newton method fails to converge within a givin accuracy</span>
    <span class="k">if</span> <span class="n">af</span> <span class="o">&gt;</span> <span class="n">eps</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;In solution: Iteration process stopped after 30 iterations.&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;hyp_theta(1/2 * omega1inv * (phi, initNewton)^t) = &quot;</span><span class="p">,</span> <span class="n">f</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="n">f</span><span class="p">]</span>
    
    <span class="c1"># Evaluate solution at the affine parameter</span>
    <span class="n">s1</span> <span class="o">=</span> <span class="n">sigma1</span><span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="n">riemannM</span><span class="p">,</span> <span class="n">minMax</span><span class="p">)</span>
    <span class="n">s2</span> <span class="o">=</span> <span class="n">sigma2</span><span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="n">riemannM</span><span class="p">,</span> <span class="n">minMax</span><span class="p">)</span>
    <span class="n">sol</span> <span class="o">=</span> <span class="o">-</span> <span class="p">((</span><span class="n">s1</span> <span class="o">*</span> <span class="n">periods_inverse</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">s2</span> <span class="o">*</span> <span class="n">periods_inverse</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span> <span class="o">/</span> <span class="p">(</span><span class="n">s1</span> <span class="o">*</span> <span class="n">periods_inverse</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">s2</span> <span class="o">*</span> <span class="n">periods_inverse</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]))</span>

    <span class="k">return</span> <span class="p">[</span><span class="n">sol</span><span class="p">,</span> <span class="n">x</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="n">x</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">affineParameter</span><span class="p">]]</span></div>

</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2024, Alexander Abesteh.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>